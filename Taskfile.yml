version: '3'

tasks:
  server:
    desc: Run the HTTP server
    deps:
      - generate
    cmds:
      - go run ./cmd/server

  build:
    desc: Build the server binary
    cmds:
      - go build -o tmp/ddash ./cmd/server

  webhooks:send:
    desc: Send continuous custom webhooks (YAML config)
    cmds:
      - go run ./cmd/webhookgenerator -config={{.CONFIG}}
    vars:
      CONFIG: cmd/webhookgenerator/sample.yaml

  events:backfill:
    desc: Backfill legacy deployments into CDEvents event store
    cmds:
      - go run ./cmd/eventbackfill -db={{.DB}} {{.FLAGS}}
    vars:
      DB: ""
      FLAGS: ""

  events:seed:
    desc: Seed sample CDEvents service data
    cmds:
      - sqlite3 {{.DB}}.sqlite < {{.SEED_FILE}}
    vars:
      DB: data/default
      SEED_FILE: internal/db/seeds/sample_services_event_store.sql

  events:publish:
    desc: Publish one CDEvents delivery event to DDash
    cmds:
      - go run ./cmd/eventpublisher -endpoint={{.ENDPOINT}} -token={{.TOKEN}} -secret={{.SECRET}} -type={{.TYPE}} -service={{.SERVICE}} -environment={{.ENV}} {{.FLAGS}}
    vars:
      ENDPOINT: ""
      TOKEN: ""
      SECRET: ""
      TYPE: service.deployed
      SERVICE: billing-api
      ENV: staging
      FLAGS: ""

  e2e:
    desc: Run local end-to-end Playwright checklist suite
    cmds:
      - |
        set -euo pipefail

        if ss -ltn '( sport = :{{.PORT}} )' | grep -q LISTEN; then
          echo "Port {{.PORT}} is already in use. Stop the existing process or run: task e2e PORT=<free-port>." >&2
          exit 1
        fi

        mkdir -p tmp
        db_path="tmp/e2e-{{.PORT}}"
        server_bin="tmp/ddash-e2e"
        server_log="/tmp/ddash-e2e-{{.PORT}}.log"
        pid_file="/tmp/ddash-e2e-{{.PORT}}.pid"
        base_url="http://localhost:{{.PORT}}"

        cleanup() {
          if [ -f "$pid_file" ]; then
            kill "$(cat "$pid_file")" 2>/dev/null || true
            rm -f "$pid_file"
          fi
          pkill -f "$server_bin" 2>/dev/null || true
        }
        trap cleanup EXIT

        go build -o "$server_bin" ./cmd/server
        DDASH_ENV=dev DDASH_SESSION_SECRET=e2e-session-secret DDASH_PORT={{.PORT}} DDASH_DB_PATH="$db_path" "$server_bin" > "$server_log" 2>&1 &
        echo "$!" > "$pid_file"

        for i in $(seq 1 40); do
          if curl -fsS "$base_url/login" >/dev/null 2>&1; then
            break
          fi
          if [ "$i" -eq 40 ]; then
            echo "Server did not start in time. Check $server_log" >&2
            exit 1
          fi
          sleep 1
        done

        sqlite3 "${db_path}.sqlite" "
        INSERT OR IGNORE INTO organizations (id,name,auth_token,join_code,webhook_secret,enabled)
        VALUES (2001,'e2e-org','e2eauthtoken01','e2ejoincode01','e2esecret01',1);
        UPDATE organizations SET
          name='e2e-org',
          auth_token='e2eauthtoken01',
          join_code='e2ejoincode01',
          webhook_secret='e2esecret01',
          enabled=1
        WHERE id=2001;

        INSERT OR IGNORE INTO users (id,github_id,email,nickname,name,avatar_url)
        VALUES (3001,'e2e-admin','e2e-admin@example.local','e2e-admin','E2E Admin','');
        UPDATE users SET github_id='e2e-admin', nickname='e2e-admin', name='E2E Admin'
        WHERE email='e2e-admin@example.local';

        INSERT OR IGNORE INTO organization_members (organization_id,user_id,role)
        SELECT 2001,id,'owner' FROM users WHERE email='e2e-admin@example.local';
        UPDATE organization_members SET role='owner'
        WHERE organization_id=2001 AND user_id=(SELECT id FROM users WHERE email='e2e-admin@example.local');

        DELETE FROM organization_join_requests
        WHERE user_id IN (SELECT id FROM users WHERE email LIKE 'e2e-joiner-%@example.local' OR email LIKE 'e2e-reject-%@example.local');
        DELETE FROM organization_members
        WHERE user_id IN (SELECT id FROM users WHERE email LIKE 'e2e-joiner-%@example.local' OR email LIKE 'e2e-reject-%@example.local');
        "

        go run ./cmd/eventpublisher -endpoint "$base_url" -token e2eauthtoken01 -secret e2esecret01 -type service.deployed -service orders -environment staging -artifact pkg:generic/orders@a1
        go run ./cmd/eventpublisher -endpoint "$base_url" -token e2eauthtoken01 -secret e2esecret01 -type service.upgraded -service orders -environment staging -artifact pkg:generic/orders@a2
        go run ./cmd/eventpublisher -endpoint "$base_url" -token e2eauthtoken01 -secret e2esecret01 -type service.deployed -service orders -environment production -artifact pkg:generic/orders@p1
        go run ./cmd/eventpublisher -endpoint "$base_url" -token e2eauthtoken01 -secret e2esecret01 -type service.deployed -service billing -environment staging -artifact pkg:generic/billing@b1

        npm ci
        npx playwright install chromium

        status=0
        E2E_BASE_URL="$base_url" npx playwright test tests/e2e/smoke.spec.js --reporter=list || status=$?
        cleanup
        trap - EXIT
        exit "$status"
    vars:
      PORT: 18080

  remote:install-systemd:
    desc: Install DDash as a systemd service on remote host
    cmds:
      - sudo ./scripts/remote/install-systemd.sh --service-name {{.SERVICE}} --app-dir {{.APP_DIR}} --user {{.USER}} --group {{.GROUP}} --env-file {{.ENV_FILE}}
    vars:
      SERVICE: ddash
      APP_DIR: /opt/ddash
      USER: ddash
      GROUP: ddash
      ENV_FILE: /etc/ddash/ddash.env

  remote:deploy:
    desc: Build locally and deploy binary + .env over SSH (rsync)
    deps:
      - generate
    cmds:
      - go build -o tmp/ddash ./cmd/server
      - ssh {{.SSH_TARGET}} "mkdir -p /tmp/ddash-deploy-{{.SERVICE}}"
      - rsync -az tmp/ddash {{.SSH_TARGET}}:/tmp/ddash-deploy-{{.SERVICE}}/ddash
      - rsync -az .env.prod {{.SSH_TARGET}}:/tmp/ddash-deploy-{{.SERVICE}}/.env
      - rsync -az scripts/remote/install-systemd.sh {{.SSH_TARGET}}:/tmp/ddash-deploy-{{.SERVICE}}/install-systemd.sh
      - ssh {{.SSH_TARGET}} "chmod +x /tmp/ddash-deploy-{{.SERVICE}}/install-systemd.sh && sudo mkdir -p {{.APP_DIR}} {{.APP_DIR}}/tmp {{.APP_DIR}}/scripts/remote && sudo install -m 0755 /tmp/ddash-deploy-{{.SERVICE}}/ddash {{.APP_DIR}}/tmp/ddash && sudo install -m 0755 /tmp/ddash-deploy-{{.SERVICE}}/install-systemd.sh {{.APP_DIR}}/scripts/remote/install-systemd.sh && sudo mkdir -p \"$(dirname {{.ENV_FILE}})\" && sudo install -m 0640 /tmp/ddash-deploy-{{.SERVICE}}/.env {{.ENV_FILE}} && sudo {{.APP_DIR}}/scripts/remote/install-systemd.sh --service-name {{.SERVICE}} --app-dir {{.APP_DIR}} --user {{.SERVICE_USER}} --group {{.SERVICE_GROUP}} --env-file {{.ENV_FILE}} && sudo systemctl restart {{.SERVICE}}"
      - ssh {{.SSH_TARGET}} "rm -rf /tmp/ddash-deploy-{{.SERVICE}}"
    vars:
      SSH_TARGET: hetzner
      APP_DIR: /opt/ddash
      SERVICE: ddash
      SERVICE_USER: ddash
      SERVICE_GROUP: ddash
      ENV_FILE: /etc/ddash/ddash.env

  sqlc:
    desc: Regenerate sqlc query code
    cmds:
      - go tool sqlc generate

  mocks:
    desc: Regenerate test mocks via mockery
    cmds:
      - go tool github.com/vektra/mockery/v3

  fmt:
    desc: Format Go code
    cmds:
      - gofmt -w .

  vet:
    desc: Run go vet
    cmds:
      - go vet ./...

  lint:
    desc: Run golangci-lint
    cmds:
      - golangci-lint run

  test:
    desc: Run all tests
    cmds:
      - go test ./...

  link:
    desc: Run golangci-lint (alias)
    cmds:
      - golangci-lint run

  generate:
    desc: Run all code generation tasks
    deps:
      - sqlc
      - mocks
    cmds:
      - templ generate
      - npx @tailwindcss/cli -i ./assets/styles.css -o ./public/styles.css

  check:
    desc: Run fmt, vet, lint, and tests
    deps:
      - fmt
      - vet
      - lint
      - test
