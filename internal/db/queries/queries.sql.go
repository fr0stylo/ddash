// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package queries

import (
	"context"
	"database/sql"
	"time"
)

const appendEventStore = `-- name: AppendEventStore :one
INSERT INTO event_store (
  organization_id,
  event_id,
  event_type,
  event_source,
  event_timestamp,
  event_ts_ms,
  subject_id,
  subject_source,
  subject_type,
  chain_id,
  raw_event_json
)
VALUES (
  ?1,
  ?2,
  ?3,
  ?4,
  ?5,
  ?6,
  ?7,
  ?8,
  ?9,
  ?10,
  ?11
)
ON CONFLICT(organization_id, event_source, event_id) DO NOTHING
RETURNING seq
`

type AppendEventStoreParams struct {
	OrganizationID int64
	EventID        string
	EventType      string
	EventSource    string
	EventTimestamp string
	EventTsMs      int64
	SubjectID      string
	SubjectSource  sql.NullString
	SubjectType    string
	ChainID        sql.NullString
	RawEventJson   string
}

func (q *Queries) AppendEventStore(ctx context.Context, arg AppendEventStoreParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, appendEventStore,
		arg.OrganizationID,
		arg.EventID,
		arg.EventType,
		arg.EventSource,
		arg.EventTimestamp,
		arg.EventTsMs,
		arg.SubjectID,
		arg.SubjectSource,
		arg.SubjectType,
		arg.ChainID,
		arg.RawEventJson,
	)
	var seq int64
	err := row.Scan(&seq)
	return seq, err
}

const countOrganizationOwners = `-- name: CountOrganizationOwners :one
SELECT COUNT(*)
FROM organization_members
WHERE organization_id = ? AND role = 'owner'
`

func (q *Queries) CountOrganizationOwners(ctx context.Context, organizationID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOrganizationOwners, organizationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createGitHubSetupIntent = `-- name: CreateGitHubSetupIntent :exec
INSERT INTO github_setup_intents (
  state,
  organization_id,
  organization_label,
  default_environment,
  expires_at
)
VALUES (
  ?1,
  ?2,
  ?3,
  ?4,
  ?5
)
`

type CreateGitHubSetupIntentParams struct {
	State              string
	OrganizationID     int64
	OrganizationLabel  string
	DefaultEnvironment string
	ExpiresAt          time.Time
}

func (q *Queries) CreateGitHubSetupIntent(ctx context.Context, arg CreateGitHubSetupIntentParams) error {
	_, err := q.db.ExecContext(ctx, createGitHubSetupIntent,
		arg.State,
		arg.OrganizationID,
		arg.OrganizationLabel,
		arg.DefaultEnvironment,
		arg.ExpiresAt,
	)
	return err
}

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO organizations (name, auth_token, join_code, webhook_secret, enabled)
VALUES (?1, ?2, ?3, ?4, ?5)
RETURNING id, name, auth_token, webhook_secret, enabled, created_at, updated_at, join_code
`

type CreateOrganizationParams struct {
	Name          string
	AuthToken     string
	JoinCode      sql.NullString
	WebhookSecret string
	Enabled       int64
}

func (q *Queries) CreateOrganization(ctx context.Context, arg CreateOrganizationParams) (Organization, error) {
	row := q.db.QueryRowContext(ctx, createOrganization,
		arg.Name,
		arg.AuthToken,
		arg.JoinCode,
		arg.WebhookSecret,
		arg.Enabled,
	)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AuthToken,
		&i.WebhookSecret,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.JoinCode,
	)
	return i, err
}

const createOrganizationEnvironmentPriority = `-- name: CreateOrganizationEnvironmentPriority :one
INSERT INTO organization_environment_priorities (organization_id, environment, sort_order)
VALUES (?1, ?2, ?3)
RETURNING id, organization_id, environment, sort_order, created_at, updated_at
`

type CreateOrganizationEnvironmentPriorityParams struct {
	OrganizationID int64
	Environment    string
	SortOrder      int64
}

func (q *Queries) CreateOrganizationEnvironmentPriority(ctx context.Context, arg CreateOrganizationEnvironmentPriorityParams) (OrganizationEnvironmentPriority, error) {
	row := q.db.QueryRowContext(ctx, createOrganizationEnvironmentPriority, arg.OrganizationID, arg.Environment, arg.SortOrder)
	var i OrganizationEnvironmentPriority
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Environment,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrganizationRequiredField = `-- name: CreateOrganizationRequiredField :one
INSERT INTO organization_required_fields (organization_id, label, field_type, sort_order, is_filterable)
VALUES (?1, ?2, ?3, ?4, ?5)
RETURNING id, organization_id, label, field_type, sort_order, created_at, updated_at, is_filterable
`

type CreateOrganizationRequiredFieldParams struct {
	OrganizationID int64
	Label          string
	FieldType      string
	SortOrder      int64
	IsFilterable   int64
}

func (q *Queries) CreateOrganizationRequiredField(ctx context.Context, arg CreateOrganizationRequiredFieldParams) (OrganizationRequiredField, error) {
	row := q.db.QueryRowContext(ctx, createOrganizationRequiredField,
		arg.OrganizationID,
		arg.Label,
		arg.FieldType,
		arg.SortOrder,
		arg.IsFilterable,
	)
	var i OrganizationRequiredField
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Label,
		&i.FieldType,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsFilterable,
	)
	return i, err
}

const deleteGitHubInstallationMapping = `-- name: DeleteGitHubInstallationMapping :execrows
DELETE FROM github_installation_mappings
WHERE installation_id = ?1
  AND organization_id = ?2
`

type DeleteGitHubInstallationMappingParams struct {
	InstallationID int64
	OrganizationID int64
}

func (q *Queries) DeleteGitHubInstallationMapping(ctx context.Context, arg DeleteGitHubInstallationMappingParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteGitHubInstallationMapping, arg.InstallationID, arg.OrganizationID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteGitHubSetupIntent = `-- name: DeleteGitHubSetupIntent :exec
DELETE FROM github_setup_intents
WHERE state = ?1
`

func (q *Queries) DeleteGitHubSetupIntent(ctx context.Context, state string) error {
	_, err := q.db.ExecContext(ctx, deleteGitHubSetupIntent, state)
	return err
}

const deleteOrganization = `-- name: DeleteOrganization :exec
DELETE FROM organizations
WHERE id = ?
`

func (q *Queries) DeleteOrganization(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteOrganization, id)
	return err
}

const deleteOrganizationEnvironmentPriorities = `-- name: DeleteOrganizationEnvironmentPriorities :exec
DELETE FROM organization_environment_priorities
WHERE organization_id = ?
`

func (q *Queries) DeleteOrganizationEnvironmentPriorities(ctx context.Context, organizationID int64) error {
	_, err := q.db.ExecContext(ctx, deleteOrganizationEnvironmentPriorities, organizationID)
	return err
}

const deleteOrganizationMember = `-- name: DeleteOrganizationMember :exec
DELETE FROM organization_members
WHERE organization_id = ? AND user_id = ?
`

type DeleteOrganizationMemberParams struct {
	OrganizationID int64
	UserID         int64
}

func (q *Queries) DeleteOrganizationMember(ctx context.Context, arg DeleteOrganizationMemberParams) error {
	_, err := q.db.ExecContext(ctx, deleteOrganizationMember, arg.OrganizationID, arg.UserID)
	return err
}

const deleteOrganizationRequiredFields = `-- name: DeleteOrganizationRequiredFields :exec
DELETE FROM organization_required_fields
WHERE organization_id = ?
`

func (q *Queries) DeleteOrganizationRequiredFields(ctx context.Context, organizationID int64) error {
	_, err := q.db.ExecContext(ctx, deleteOrganizationRequiredFields, organizationID)
	return err
}

const deleteServiceDependency = `-- name: DeleteServiceDependency :exec
DELETE FROM service_dependencies
WHERE organization_id = ?1
  AND service_name = ?2
  AND depends_on_service_name = ?3
`

type DeleteServiceDependencyParams struct {
	OrganizationID       int64
	ServiceName          string
	DependsOnServiceName string
}

func (q *Queries) DeleteServiceDependency(ctx context.Context, arg DeleteServiceDependencyParams) error {
	_, err := q.db.ExecContext(ctx, deleteServiceDependency, arg.OrganizationID, arg.ServiceName, arg.DependsOnServiceName)
	return err
}

const deleteServiceMetadataByService = `-- name: DeleteServiceMetadataByService :exec
DELETE FROM service_metadata
WHERE organization_id = ?1
  AND service_name = ?2
`

type DeleteServiceMetadataByServiceParams struct {
	OrganizationID int64
	ServiceName    string
}

func (q *Queries) DeleteServiceMetadataByService(ctx context.Context, arg DeleteServiceMetadataByServiceParams) error {
	_, err := q.db.ExecContext(ctx, deleteServiceMetadataByService, arg.OrganizationID, arg.ServiceName)
	return err
}

const getDefaultOrganization = `-- name: GetDefaultOrganization :one
SELECT id, name, auth_token, webhook_secret, enabled, created_at, updated_at, join_code
FROM organizations
ORDER BY id
LIMIT 1
`

func (q *Queries) GetDefaultOrganization(ctx context.Context) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getDefaultOrganization)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AuthToken,
		&i.WebhookSecret,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.JoinCode,
	)
	return i, err
}

const getGitHubSetupIntentByState = `-- name: GetGitHubSetupIntentByState :one
SELECT
  state,
  organization_id,
  organization_label,
  default_environment,
  expires_at
FROM github_setup_intents
WHERE state = ?1
LIMIT 1
`

type GetGitHubSetupIntentByStateRow struct {
	State              string
	OrganizationID     int64
	OrganizationLabel  string
	DefaultEnvironment string
	ExpiresAt          time.Time
}

func (q *Queries) GetGitHubSetupIntentByState(ctx context.Context, state string) (GetGitHubSetupIntentByStateRow, error) {
	row := q.db.QueryRowContext(ctx, getGitHubSetupIntentByState, state)
	var i GetGitHubSetupIntentByStateRow
	err := row.Scan(
		&i.State,
		&i.OrganizationID,
		&i.OrganizationLabel,
		&i.DefaultEnvironment,
		&i.ExpiresAt,
	)
	return i, err
}

const getOrganizationByAuthToken = `-- name: GetOrganizationByAuthToken :one
SELECT id, name, auth_token, webhook_secret, enabled, created_at, updated_at, join_code
FROM organizations
WHERE auth_token = ?
LIMIT 1
`

func (q *Queries) GetOrganizationByAuthToken(ctx context.Context, authToken string) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByAuthToken, authToken)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AuthToken,
		&i.WebhookSecret,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.JoinCode,
	)
	return i, err
}

const getOrganizationByGitHubInstallationID = `-- name: GetOrganizationByGitHubInstallationID :one
SELECT o.id, o.name, o.auth_token, o.webhook_secret, o.enabled, o.created_at, o.updated_at, o.join_code
FROM organizations o
JOIN github_installation_mappings m ON m.organization_id = o.id
WHERE m.installation_id = ?1
  AND m.enabled = 1
  AND o.enabled = 1
LIMIT 1
`

func (q *Queries) GetOrganizationByGitHubInstallationID(ctx context.Context, installationID int64) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByGitHubInstallationID, installationID)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AuthToken,
		&i.WebhookSecret,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.JoinCode,
	)
	return i, err
}

const getOrganizationByID = `-- name: GetOrganizationByID :one
SELECT id, name, auth_token, webhook_secret, enabled, created_at, updated_at, join_code
FROM organizations
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetOrganizationByID(ctx context.Context, id int64) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByID, id)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AuthToken,
		&i.WebhookSecret,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.JoinCode,
	)
	return i, err
}

const getOrganizationByJoinCode = `-- name: GetOrganizationByJoinCode :one
SELECT id, name, auth_token, webhook_secret, enabled, created_at, updated_at, join_code
FROM organizations
WHERE join_code = ?
LIMIT 1
`

func (q *Queries) GetOrganizationByJoinCode(ctx context.Context, joinCode sql.NullString) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByJoinCode, joinCode)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AuthToken,
		&i.WebhookSecret,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.JoinCode,
	)
	return i, err
}

const getOrganizationMemberRole = `-- name: GetOrganizationMemberRole :one
SELECT role
FROM organization_members
WHERE organization_id = ? AND user_id = ?
LIMIT 1
`

type GetOrganizationMemberRoleParams struct {
	OrganizationID int64
	UserID         int64
}

func (q *Queries) GetOrganizationMemberRole(ctx context.Context, arg GetOrganizationMemberRoleParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationMemberRole, arg.OrganizationID, arg.UserID)
	var role string
	err := row.Scan(&role)
	return role, err
}

const getOrganizationRenderVersion = `-- name: GetOrganizationRenderVersion :one
SELECT COALESCE(MAX(version_value), 0) AS version
FROM (
  SELECT COALESCE(MAX(seq), 0) AS version_value
  FROM event_store
  WHERE event_store.organization_id = ?1

  UNION ALL

  SELECT COALESCE(MAX(CAST(strftime('%s', updated_at) AS INTEGER)), 0) AS version_value
  FROM organizations
  WHERE id = ?1

  UNION ALL

  SELECT COALESCE(MAX(CAST(strftime('%s', updated_at) AS INTEGER)), 0) AS version_value
  FROM service_metadata
  WHERE service_metadata.organization_id = ?1

  UNION ALL

  SELECT COALESCE(MAX(CAST(strftime('%s', updated_at) AS INTEGER)), 0) AS version_value
  FROM organization_required_fields
  WHERE organization_required_fields.organization_id = ?1

  UNION ALL

  SELECT COALESCE(MAX(CAST(strftime('%s', updated_at) AS INTEGER)), 0) AS version_value
  FROM organization_environment_priorities
  WHERE organization_environment_priorities.organization_id = ?1

  UNION ALL

  SELECT COALESCE(MAX(CAST(strftime('%s', updated_at) AS INTEGER)), 0) AS version_value
  FROM organization_features
  WHERE organization_features.organization_id = ?1

  UNION ALL

  SELECT COALESCE(MAX(CAST(strftime('%s', updated_at) AS INTEGER)), 0) AS version_value
  FROM organization_preferences
  WHERE organization_preferences.organization_id = ?1

  UNION ALL

  SELECT COALESCE(MAX(CAST(strftime('%s', created_at) AS INTEGER)), 0) AS version_value
  FROM service_dependencies
  WHERE service_dependencies.organization_id = ?1
)
`

func (q *Queries) GetOrganizationRenderVersion(ctx context.Context, orgID int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationRenderVersion, orgID)
	var version interface{}
	err := row.Scan(&version)
	return version, err
}

const getServiceLatestFromEvents = `-- name: GetServiceLatestFromEvents :one
SELECT
  CASE
    WHEN instr(es.subject_id, '/') > 0 THEN substr(es.subject_id, instr(es.subject_id, '/') + 1)
    ELSE es.subject_id
  END AS service_name,
  es.subject_id AS raw_subject_id,
  es.event_timestamp AS last_deploy_at,
  'cdevents' AS integration_type
FROM event_store es
WHERE es.subject_type = 'service'
  AND es.organization_id = ?1
  AND (es.subject_id = ?2 OR substr(es.subject_id, instr(es.subject_id, '/') + 1) = ?2)
ORDER BY es.event_ts_ms DESC, es.seq DESC
LIMIT 1
`

type GetServiceLatestFromEventsParams struct {
	OrganizationID int64
	Service        string
}

type GetServiceLatestFromEventsRow struct {
	ServiceName     interface{}
	RawSubjectID    string
	LastDeployAt    string
	IntegrationType string
}

func (q *Queries) GetServiceLatestFromEvents(ctx context.Context, arg GetServiceLatestFromEventsParams) (GetServiceLatestFromEventsRow, error) {
	row := q.db.QueryRowContext(ctx, getServiceLatestFromEvents, arg.OrganizationID, arg.Service)
	var i GetServiceLatestFromEventsRow
	err := row.Scan(
		&i.ServiceName,
		&i.RawSubjectID,
		&i.LastDeployAt,
		&i.IntegrationType,
	)
	return i, err
}

const getUserByEmailOrNickname = `-- name: GetUserByEmailOrNickname :one
SELECT id, github_id, email, nickname, name, avatar_url, created_at, updated_at
FROM users
WHERE email = ? OR nickname = ?
LIMIT 1
`

type GetUserByEmailOrNicknameParams struct {
	Email    string
	Nickname string
}

func (q *Queries) GetUserByEmailOrNickname(ctx context.Context, arg GetUserByEmailOrNicknameParams) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmailOrNickname, arg.Email, arg.Nickname)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.Email,
		&i.Nickname,
		&i.Name,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, github_id, email, nickname, name, avatar_url, created_at, updated_at
FROM users
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.Email,
		&i.Nickname,
		&i.Name,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDeploymentHistoryByServiceFromEvents = `-- name: ListDeploymentHistoryByServiceFromEvents :many
SELECT
  es.event_timestamp AS deployed_at,
  COALESCE(json_extract(es.raw_event_json, '$.subject.content.artifactId'), '') AS release_ref,
  COALESCE(NULLIF(json_extract(es.raw_event_json, '$.subject.content.environment.id'), ''), 'unknown') AS environment
FROM event_store es
WHERE es.subject_type = 'service'
  AND es.organization_id = ?1
  AND (es.subject_id = ?2 OR substr(es.subject_id, instr(es.subject_id, '/') + 1) = ?2)
ORDER BY es.event_ts_ms DESC, es.seq DESC
LIMIT ?3
`

type ListDeploymentHistoryByServiceFromEventsParams struct {
	OrganizationID int64
	Service        string
	Limit          int64
}

type ListDeploymentHistoryByServiceFromEventsRow struct {
	DeployedAt  string
	ReleaseRef  interface{}
	Environment interface{}
}

func (q *Queries) ListDeploymentHistoryByServiceFromEvents(ctx context.Context, arg ListDeploymentHistoryByServiceFromEventsParams) ([]ListDeploymentHistoryByServiceFromEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, listDeploymentHistoryByServiceFromEvents, arg.OrganizationID, arg.Service, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeploymentHistoryByServiceFromEventsRow
	for rows.Next() {
		var i ListDeploymentHistoryByServiceFromEventsRow
		if err := rows.Scan(&i.DeployedAt, &i.ReleaseRef, &i.Environment); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeploymentsFromEvents = `-- name: ListDeploymentsFromEvents :many
SELECT
  es.event_timestamp AS deployed_at,
  CASE
    WHEN instr(es.subject_id, '/') > 0 THEN substr(es.subject_id, instr(es.subject_id, '/') + 1)
    ELSE es.subject_id
  END AS service,
  COALESCE(NULLIF(json_extract(es.raw_event_json, '$.subject.content.environment.id'), ''), 'unknown') AS environment,
  CASE
    WHEN es.event_type LIKE 'dev.cdevents.service.deployed.%' THEN 'success'
    WHEN es.event_type LIKE 'dev.cdevents.service.upgraded.%' THEN 'success'
    WHEN es.event_type LIKE 'dev.cdevents.service.published.%' THEN 'success'
    WHEN es.event_type LIKE 'dev.cdevents.service.rolledback.%' THEN 'error'
    WHEN es.event_type LIKE 'dev.cdevents.service.removed.%' THEN 'error'
    ELSE 'queued'
  END AS status
FROM event_store es
WHERE es.subject_type = 'service'
  AND es.organization_id = ?1
  AND (?2 = '' OR ?2 = 'all' OR json_extract(es.raw_event_json, '$.subject.content.environment.id') = ?2)
  AND (?3 = '' OR ?3 = 'all' OR es.subject_id = ?3 OR substr(es.subject_id, instr(es.subject_id, '/') + 1) = ?3)
ORDER BY es.event_ts_ms DESC, es.seq DESC
`

type ListDeploymentsFromEventsParams struct {
	OrganizationID int64
	Env            interface{}
	Service        interface{}
}

type ListDeploymentsFromEventsRow struct {
	DeployedAt  string
	Service     interface{}
	Environment interface{}
	Status      string
}

func (q *Queries) ListDeploymentsFromEvents(ctx context.Context, arg ListDeploymentsFromEventsParams) ([]ListDeploymentsFromEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, listDeploymentsFromEvents, arg.OrganizationID, arg.Env, arg.Service)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeploymentsFromEventsRow
	for rows.Next() {
		var i ListDeploymentsFromEventsRow
		if err := rows.Scan(
			&i.DeployedAt,
			&i.Service,
			&i.Environment,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDistinctServiceEnvironmentsFromEvents = `-- name: ListDistinctServiceEnvironmentsFromEvents :many
SELECT DISTINCT COALESCE(NULLIF(json_extract(es.raw_event_json, '$.subject.content.environment.id'), ''), 'unknown') AS environment
FROM event_store es
WHERE es.organization_id = ?1
  AND es.subject_type = 'service'
ORDER BY environment
`

func (q *Queries) ListDistinctServiceEnvironmentsFromEvents(ctx context.Context, organizationID int64) ([]interface{}, error) {
	rows, err := q.db.QueryContext(ctx, listDistinctServiceEnvironmentsFromEvents, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var environment interface{}
		if err := rows.Scan(&environment); err != nil {
			return nil, err
		}
		items = append(items, environment)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGitHubInstallationMappings = `-- name: ListGitHubInstallationMappings :many
SELECT
  installation_id,
  organization_id,
  organization_label,
  default_environment,
  enabled
FROM github_installation_mappings
WHERE organization_id = ?1
ORDER BY installation_id ASC
`

type ListGitHubInstallationMappingsRow struct {
	InstallationID     int64
	OrganizationID     int64
	OrganizationLabel  string
	DefaultEnvironment string
	Enabled            int64
}

func (q *Queries) ListGitHubInstallationMappings(ctx context.Context, organizationID int64) ([]ListGitHubInstallationMappingsRow, error) {
	rows, err := q.db.QueryContext(ctx, listGitHubInstallationMappings, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGitHubInstallationMappingsRow
	for rows.Next() {
		var i ListGitHubInstallationMappingsRow
		if err := rows.Scan(
			&i.InstallationID,
			&i.OrganizationID,
			&i.OrganizationLabel,
			&i.DefaultEnvironment,
			&i.Enabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLegacyDeploymentsForBackfill = `-- name: ListLegacyDeploymentsForBackfill :many
SELECT
  d.id,
  d.deployed_at,
  s.name AS service,
  e.name AS environment,
  d.status,
  d.release_ref
FROM deployments d
JOIN services s ON s.id = d.service_id
JOIN environments e ON e.id = d.environment_id
ORDER BY d.id
`

type ListLegacyDeploymentsForBackfillRow struct {
	ID          int64
	DeployedAt  string
	Service     string
	Environment string
	Status      string
	ReleaseRef  sql.NullString
}

func (q *Queries) ListLegacyDeploymentsForBackfill(ctx context.Context) ([]ListLegacyDeploymentsForBackfillRow, error) {
	rows, err := q.db.QueryContext(ctx, listLegacyDeploymentsForBackfill)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLegacyDeploymentsForBackfillRow
	for rows.Next() {
		var i ListLegacyDeploymentsForBackfillRow
		if err := rows.Scan(
			&i.ID,
			&i.DeployedAt,
			&i.Service,
			&i.Environment,
			&i.Status,
			&i.ReleaseRef,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationEnvironmentPriorities = `-- name: ListOrganizationEnvironmentPriorities :many
SELECT id, organization_id, environment, sort_order
FROM organization_environment_priorities
WHERE organization_id = ?
ORDER BY sort_order, id
`

type ListOrganizationEnvironmentPrioritiesRow struct {
	ID             int64
	OrganizationID int64
	Environment    string
	SortOrder      int64
}

func (q *Queries) ListOrganizationEnvironmentPriorities(ctx context.Context, organizationID int64) ([]ListOrganizationEnvironmentPrioritiesRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationEnvironmentPriorities, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrganizationEnvironmentPrioritiesRow
	for rows.Next() {
		var i ListOrganizationEnvironmentPrioritiesRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Environment,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationFeatures = `-- name: ListOrganizationFeatures :many
SELECT feature_key, is_enabled
FROM organization_features
WHERE organization_id = ?
ORDER BY feature_key
`

type ListOrganizationFeaturesRow struct {
	FeatureKey string
	IsEnabled  int64
}

func (q *Queries) ListOrganizationFeatures(ctx context.Context, organizationID int64) ([]ListOrganizationFeaturesRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationFeatures, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrganizationFeaturesRow
	for rows.Next() {
		var i ListOrganizationFeaturesRow
		if err := rows.Scan(&i.FeatureKey, &i.IsEnabled); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationMembers = `-- name: ListOrganizationMembers :many
SELECT
  u.id AS user_id,
  u.email,
  u.nickname,
  u.name,
  u.avatar_url,
  m.role
FROM organization_members m
JOIN users u ON u.id = m.user_id
WHERE m.organization_id = ?
ORDER BY
  CASE m.role WHEN 'owner' THEN 0 WHEN 'admin' THEN 1 ELSE 2 END,
  COALESCE(NULLIF(u.name, ''), u.nickname, u.email)
`

type ListOrganizationMembersRow struct {
	UserID    int64
	Email     string
	Nickname  string
	Name      sql.NullString
	AvatarUrl sql.NullString
	Role      string
}

func (q *Queries) ListOrganizationMembers(ctx context.Context, organizationID int64) ([]ListOrganizationMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationMembers, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrganizationMembersRow
	for rows.Next() {
		var i ListOrganizationMembersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.Nickname,
			&i.Name,
			&i.AvatarUrl,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationPreferences = `-- name: ListOrganizationPreferences :many
SELECT preference_key, preference_value
FROM organization_preferences
WHERE organization_id = ?
ORDER BY preference_key
`

type ListOrganizationPreferencesRow struct {
	PreferenceKey   string
	PreferenceValue string
}

func (q *Queries) ListOrganizationPreferences(ctx context.Context, organizationID int64) ([]ListOrganizationPreferencesRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationPreferences, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrganizationPreferencesRow
	for rows.Next() {
		var i ListOrganizationPreferencesRow
		if err := rows.Scan(&i.PreferenceKey, &i.PreferenceValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationRequiredFields = `-- name: ListOrganizationRequiredFields :many
SELECT id, organization_id, label, field_type, sort_order, is_filterable
FROM organization_required_fields
WHERE organization_id = ?
ORDER BY sort_order, id
`

type ListOrganizationRequiredFieldsRow struct {
	ID             int64
	OrganizationID int64
	Label          string
	FieldType      string
	SortOrder      int64
	IsFilterable   int64
}

func (q *Queries) ListOrganizationRequiredFields(ctx context.Context, organizationID int64) ([]ListOrganizationRequiredFieldsRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationRequiredFields, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrganizationRequiredFieldsRow
	for rows.Next() {
		var i ListOrganizationRequiredFieldsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Label,
			&i.FieldType,
			&i.SortOrder,
			&i.IsFilterable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizations = `-- name: ListOrganizations :many
SELECT id, name, auth_token, webhook_secret, enabled, created_at, updated_at, join_code
FROM organizations
ORDER BY name, id
`

func (q *Queries) ListOrganizations(ctx context.Context) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AuthToken,
			&i.WebhookSecret,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.JoinCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationsByUser = `-- name: ListOrganizationsByUser :many
SELECT o.id, o.name, o.auth_token, o.webhook_secret, o.enabled, o.created_at, o.updated_at, o.join_code
FROM organizations o
JOIN organization_members m ON m.organization_id = o.id
WHERE m.user_id = ?
ORDER BY o.name, o.id
`

func (q *Queries) ListOrganizationsByUser(ctx context.Context, userID int64) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AuthToken,
			&i.WebhookSecret,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.JoinCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingOrganizationJoinRequests = `-- name: ListPendingOrganizationJoinRequests :many
SELECT
  r.organization_id,
  r.user_id,
  r.request_code,
  r.status,
  u.email,
  u.nickname,
  u.name
FROM organization_join_requests r
JOIN users u ON u.id = r.user_id
WHERE r.organization_id = ?
  AND r.status = 'pending'
ORDER BY r.created_at, r.id
`

type ListPendingOrganizationJoinRequestsRow struct {
	OrganizationID int64
	UserID         int64
	RequestCode    string
	Status         string
	Email          string
	Nickname       string
	Name           sql.NullString
}

func (q *Queries) ListPendingOrganizationJoinRequests(ctx context.Context, organizationID int64) ([]ListPendingOrganizationJoinRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPendingOrganizationJoinRequests, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPendingOrganizationJoinRequestsRow
	for rows.Next() {
		var i ListPendingOrganizationJoinRequestsRow
		if err := rows.Scan(
			&i.OrganizationID,
			&i.UserID,
			&i.RequestCode,
			&i.Status,
			&i.Email,
			&i.Nickname,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceDependants = `-- name: ListServiceDependants :many
SELECT service_name
FROM service_dependencies
WHERE organization_id = ?1
  AND depends_on_service_name = ?2
ORDER BY service_name
`

type ListServiceDependantsParams struct {
	OrganizationID int64
	ServiceName    string
}

func (q *Queries) ListServiceDependants(ctx context.Context, arg ListServiceDependantsParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listServiceDependants, arg.OrganizationID, arg.ServiceName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var service_name string
		if err := rows.Scan(&service_name); err != nil {
			return nil, err
		}
		items = append(items, service_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceDependencies = `-- name: ListServiceDependencies :many
SELECT depends_on_service_name
FROM service_dependencies
WHERE organization_id = ?1
  AND service_name = ?2
ORDER BY depends_on_service_name
`

type ListServiceDependenciesParams struct {
	OrganizationID int64
	ServiceName    string
}

func (q *Queries) ListServiceDependencies(ctx context.Context, arg ListServiceDependenciesParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listServiceDependencies, arg.OrganizationID, arg.ServiceName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var depends_on_service_name string
		if err := rows.Scan(&depends_on_service_name); err != nil {
			return nil, err
		}
		items = append(items, depends_on_service_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceEnvironmentsFromEvents = `-- name: ListServiceEnvironmentsFromEvents :many
WITH service_events AS (
  SELECT
    es.seq,
    COALESCE(NULLIF(json_extract(es.raw_event_json, '$.subject.content.environment.id'), ''), 'unknown') AS environment,
    es.event_timestamp,
    es.event_ts_ms,
    COALESCE(json_extract(es.raw_event_json, '$.subject.content.artifactId'), '') AS artifact_id
  FROM event_store es
  WHERE es.subject_type = 'service'
    AND es.organization_id = ?1
    AND (es.subject_id = ?2 OR substr(es.subject_id, instr(es.subject_id, '/') + 1) = ?2)
), ranked AS (
  SELECT
    environment,
    event_timestamp,
    artifact_id,
    row_number() OVER (
      PARTITION BY environment
      ORDER BY event_ts_ms DESC, seq DESC
    ) AS rn
  FROM service_events
)
SELECT
  environment AS name,
  event_timestamp AS released_at,
  artifact_id AS ref
FROM ranked
WHERE rn = 1
ORDER BY released_at DESC
`

type ListServiceEnvironmentsFromEventsParams struct {
	OrganizationID int64
	Service        string
}

type ListServiceEnvironmentsFromEventsRow struct {
	Name       interface{}
	ReleasedAt string
	Ref        interface{}
}

func (q *Queries) ListServiceEnvironmentsFromEvents(ctx context.Context, arg ListServiceEnvironmentsFromEventsParams) ([]ListServiceEnvironmentsFromEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, listServiceEnvironmentsFromEvents, arg.OrganizationID, arg.Service)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListServiceEnvironmentsFromEventsRow
	for rows.Next() {
		var i ListServiceEnvironmentsFromEventsRow
		if err := rows.Scan(&i.Name, &i.ReleasedAt, &i.Ref); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceInstancesByEnvFromEvents = `-- name: ListServiceInstancesByEnvFromEvents :many
WITH service_events AS (
  SELECT
    es.seq,
    es.event_type,
    es.event_timestamp,
    es.event_ts_ms,
    CASE
      WHEN instr(es.subject_id, '/') > 0 THEN substr(es.subject_id, instr(es.subject_id, '/') + 1)
      ELSE es.subject_id
    END AS service_name,
    COALESCE(NULLIF(json_extract(es.raw_event_json, '$.subject.content.environment.id'), ''), 'unknown') AS environment,
    COALESCE(json_extract(es.raw_event_json, '$.subject.content.artifactId'), '') AS artifact_id,
    CASE
      WHEN es.event_type LIKE 'dev.cdevents.service.deployed.%' THEN 'synced'
      WHEN es.event_type LIKE 'dev.cdevents.service.upgraded.%' THEN 'synced'
      WHEN es.event_type LIKE 'dev.cdevents.service.published.%' THEN 'synced'
      WHEN es.event_type LIKE 'dev.cdevents.service.rolledback.%' THEN 'warning'
      WHEN es.event_type LIKE 'dev.cdevents.service.removed.%' THEN 'out-of-sync'
      ELSE 'unknown'
    END AS status
  FROM event_store es
  WHERE es.subject_type = 'service'
    AND es.organization_id = ?1
    AND COALESCE(NULLIF(json_extract(es.raw_event_json, '$.subject.content.environment.id'), ''), 'unknown') = ?2
), ranked AS (
  SELECT
    service_name,
    environment,
    status,
    event_timestamp,
    artifact_id,
    row_number() OVER (
      PARTITION BY service_name
      ORDER BY event_ts_ms DESC, seq DESC
    ) AS rn
  FROM service_events
)
SELECT
  service_name,
  environment,
  status,
  event_timestamp AS last_deploy_at,
  artifact_id
FROM ranked
WHERE rn = 1
ORDER BY service_name, environment
`

type ListServiceInstancesByEnvFromEventsParams struct {
	OrganizationID int64
	Env            string
}

type ListServiceInstancesByEnvFromEventsRow struct {
	ServiceName  interface{}
	Environment  interface{}
	Status       string
	LastDeployAt string
	ArtifactID   interface{}
}

func (q *Queries) ListServiceInstancesByEnvFromEvents(ctx context.Context, arg ListServiceInstancesByEnvFromEventsParams) ([]ListServiceInstancesByEnvFromEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, listServiceInstancesByEnvFromEvents, arg.OrganizationID, arg.Env)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListServiceInstancesByEnvFromEventsRow
	for rows.Next() {
		var i ListServiceInstancesByEnvFromEventsRow
		if err := rows.Scan(
			&i.ServiceName,
			&i.Environment,
			&i.Status,
			&i.LastDeployAt,
			&i.ArtifactID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceInstancesFromEvents = `-- name: ListServiceInstancesFromEvents :many
WITH service_events AS (
  SELECT
    es.seq,
    es.event_type,
    es.event_timestamp,
    es.event_ts_ms,
    CASE
      WHEN instr(es.subject_id, '/') > 0 THEN substr(es.subject_id, instr(es.subject_id, '/') + 1)
      ELSE es.subject_id
    END AS service_name,
    COALESCE(NULLIF(json_extract(es.raw_event_json, '$.subject.content.environment.id'), ''), 'unknown') AS environment,
    COALESCE(json_extract(es.raw_event_json, '$.subject.content.artifactId'), '') AS artifact_id,
    CASE
      WHEN es.event_type LIKE 'dev.cdevents.service.deployed.%' THEN 'synced'
      WHEN es.event_type LIKE 'dev.cdevents.service.upgraded.%' THEN 'synced'
      WHEN es.event_type LIKE 'dev.cdevents.service.published.%' THEN 'synced'
      WHEN es.event_type LIKE 'dev.cdevents.service.rolledback.%' THEN 'warning'
      WHEN es.event_type LIKE 'dev.cdevents.service.removed.%' THEN 'out-of-sync'
      ELSE 'unknown'
    END AS status
  FROM event_store es
  WHERE es.subject_type = 'service'
    AND es.organization_id = ?1
), ranked AS (
  SELECT
    service_name,
    environment,
    status,
    event_timestamp,
    artifact_id,
    row_number() OVER (
      PARTITION BY service_name
      ORDER BY event_ts_ms DESC, seq DESC
    ) AS rn
  FROM service_events
)
SELECT
  service_name,
  environment,
  status,
  event_timestamp AS last_deploy_at,
  artifact_id
FROM ranked
WHERE rn = 1
ORDER BY service_name, environment
`

type ListServiceInstancesFromEventsRow struct {
	ServiceName  interface{}
	Environment  interface{}
	Status       string
	LastDeployAt string
	ArtifactID   interface{}
}

func (q *Queries) ListServiceInstancesFromEvents(ctx context.Context, organizationID int64) ([]ListServiceInstancesFromEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, listServiceInstancesFromEvents, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListServiceInstancesFromEventsRow
	for rows.Next() {
		var i ListServiceInstancesFromEventsRow
		if err := rows.Scan(
			&i.ServiceName,
			&i.Environment,
			&i.Status,
			&i.LastDeployAt,
			&i.ArtifactID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceMetadataByOrganization = `-- name: ListServiceMetadataByOrganization :many
SELECT service_name, label, value
FROM service_metadata
WHERE organization_id = ?1
ORDER BY service_name, label
`

type ListServiceMetadataByOrganizationRow struct {
	ServiceName string
	Label       string
	Value       string
}

func (q *Queries) ListServiceMetadataByOrganization(ctx context.Context, organizationID int64) ([]ListServiceMetadataByOrganizationRow, error) {
	rows, err := q.db.QueryContext(ctx, listServiceMetadataByOrganization, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListServiceMetadataByOrganizationRow
	for rows.Next() {
		var i ListServiceMetadataByOrganizationRow
		if err := rows.Scan(&i.ServiceName, &i.Label, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceMetadataByService = `-- name: ListServiceMetadataByService :many
SELECT label, value
FROM service_metadata
WHERE organization_id = ?1
  AND service_name = ?2
ORDER BY label
`

type ListServiceMetadataByServiceParams struct {
	OrganizationID int64
	ServiceName    string
}

type ListServiceMetadataByServiceRow struct {
	Label string
	Value string
}

func (q *Queries) ListServiceMetadataByService(ctx context.Context, arg ListServiceMetadataByServiceParams) ([]ListServiceMetadataByServiceRow, error) {
	rows, err := q.db.QueryContext(ctx, listServiceMetadataByService, arg.OrganizationID, arg.ServiceName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListServiceMetadataByServiceRow
	for rows.Next() {
		var i ListServiceMetadataByServiceRow
		if err := rows.Scan(&i.Label, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setOrganizationJoinRequestStatus = `-- name: SetOrganizationJoinRequestStatus :exec
UPDATE organization_join_requests
SET status = ?, reviewed_by = ?, reviewed_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE organization_id = ? AND user_id = ?
`

type SetOrganizationJoinRequestStatusParams struct {
	Status         string
	ReviewedBy     sql.NullInt64
	OrganizationID int64
	UserID         int64
}

func (q *Queries) SetOrganizationJoinRequestStatus(ctx context.Context, arg SetOrganizationJoinRequestStatusParams) error {
	_, err := q.db.ExecContext(ctx, setOrganizationJoinRequestStatus,
		arg.Status,
		arg.ReviewedBy,
		arg.OrganizationID,
		arg.UserID,
	)
	return err
}

const updateOrganizationEnabled = `-- name: UpdateOrganizationEnabled :exec
UPDATE organizations
SET enabled = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateOrganizationEnabledParams struct {
	Enabled int64
	ID      int64
}

func (q *Queries) UpdateOrganizationEnabled(ctx context.Context, arg UpdateOrganizationEnabledParams) error {
	_, err := q.db.ExecContext(ctx, updateOrganizationEnabled, arg.Enabled, arg.ID)
	return err
}

const updateOrganizationName = `-- name: UpdateOrganizationName :exec
UPDATE organizations
SET name = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateOrganizationNameParams struct {
	Name string
	ID   int64
}

func (q *Queries) UpdateOrganizationName(ctx context.Context, arg UpdateOrganizationNameParams) error {
	_, err := q.db.ExecContext(ctx, updateOrganizationName, arg.Name, arg.ID)
	return err
}

const updateOrganizationSecrets = `-- name: UpdateOrganizationSecrets :exec
UPDATE organizations
SET auth_token = ?, webhook_secret = ?, enabled = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateOrganizationSecretsParams struct {
	AuthToken     string
	WebhookSecret string
	Enabled       int64
	ID            int64
}

func (q *Queries) UpdateOrganizationSecrets(ctx context.Context, arg UpdateOrganizationSecretsParams) error {
	_, err := q.db.ExecContext(ctx, updateOrganizationSecrets,
		arg.AuthToken,
		arg.WebhookSecret,
		arg.Enabled,
		arg.ID,
	)
	return err
}

const upsertGitHubInstallationMapping = `-- name: UpsertGitHubInstallationMapping :exec
INSERT INTO github_installation_mappings (
  installation_id,
  organization_id,
  organization_label,
  default_environment,
  enabled
)
VALUES (
  ?1,
  ?2,
  ?3,
  ?4,
  ?5
)
ON CONFLICT(installation_id) DO UPDATE SET
  organization_id = excluded.organization_id,
  organization_label = excluded.organization_label,
  default_environment = excluded.default_environment,
  enabled = excluded.enabled,
  updated_at = CURRENT_TIMESTAMP
`

type UpsertGitHubInstallationMappingParams struct {
	InstallationID     int64
	OrganizationID     int64
	OrganizationLabel  string
	DefaultEnvironment string
	Enabled            int64
}

func (q *Queries) UpsertGitHubInstallationMapping(ctx context.Context, arg UpsertGitHubInstallationMappingParams) error {
	_, err := q.db.ExecContext(ctx, upsertGitHubInstallationMapping,
		arg.InstallationID,
		arg.OrganizationID,
		arg.OrganizationLabel,
		arg.DefaultEnvironment,
		arg.Enabled,
	)
	return err
}

const upsertOrganizationFeature = `-- name: UpsertOrganizationFeature :exec
INSERT INTO organization_features (organization_id, feature_key, is_enabled)
VALUES (?, ?, ?)
ON CONFLICT(organization_id, feature_key) DO UPDATE SET
  is_enabled = excluded.is_enabled,
  updated_at = CURRENT_TIMESTAMP
`

type UpsertOrganizationFeatureParams struct {
	OrganizationID int64
	FeatureKey     string
	IsEnabled      int64
}

func (q *Queries) UpsertOrganizationFeature(ctx context.Context, arg UpsertOrganizationFeatureParams) error {
	_, err := q.db.ExecContext(ctx, upsertOrganizationFeature, arg.OrganizationID, arg.FeatureKey, arg.IsEnabled)
	return err
}

const upsertOrganizationJoinRequest = `-- name: UpsertOrganizationJoinRequest :exec
INSERT INTO organization_join_requests (organization_id, user_id, request_code, status)
VALUES (?, ?, ?, 'pending')
ON CONFLICT(organization_id, user_id) DO UPDATE SET
  request_code = excluded.request_code,
  status = 'pending',
  reviewed_by = NULL,
  reviewed_at = NULL,
  updated_at = CURRENT_TIMESTAMP
`

type UpsertOrganizationJoinRequestParams struct {
	OrganizationID int64
	UserID         int64
	RequestCode    string
}

func (q *Queries) UpsertOrganizationJoinRequest(ctx context.Context, arg UpsertOrganizationJoinRequestParams) error {
	_, err := q.db.ExecContext(ctx, upsertOrganizationJoinRequest, arg.OrganizationID, arg.UserID, arg.RequestCode)
	return err
}

const upsertOrganizationMember = `-- name: UpsertOrganizationMember :exec
INSERT INTO organization_members (organization_id, user_id, role)
VALUES (?, ?, ?)
ON CONFLICT(organization_id, user_id) DO UPDATE SET
  role = excluded.role,
  updated_at = CURRENT_TIMESTAMP
`

type UpsertOrganizationMemberParams struct {
	OrganizationID int64
	UserID         int64
	Role           string
}

func (q *Queries) UpsertOrganizationMember(ctx context.Context, arg UpsertOrganizationMemberParams) error {
	_, err := q.db.ExecContext(ctx, upsertOrganizationMember, arg.OrganizationID, arg.UserID, arg.Role)
	return err
}

const upsertOrganizationPreference = `-- name: UpsertOrganizationPreference :exec
INSERT INTO organization_preferences (organization_id, preference_key, preference_value)
VALUES (?, ?, ?)
ON CONFLICT(organization_id, preference_key) DO UPDATE SET
  preference_value = excluded.preference_value,
  updated_at = CURRENT_TIMESTAMP
`

type UpsertOrganizationPreferenceParams struct {
	OrganizationID  int64
	PreferenceKey   string
	PreferenceValue string
}

func (q *Queries) UpsertOrganizationPreference(ctx context.Context, arg UpsertOrganizationPreferenceParams) error {
	_, err := q.db.ExecContext(ctx, upsertOrganizationPreference, arg.OrganizationID, arg.PreferenceKey, arg.PreferenceValue)
	return err
}

const upsertServiceChangeLinkFromEventSeq = `-- name: UpsertServiceChangeLinkFromEventSeq :exec
INSERT INTO service_change_links (
  organization_id,
  service_name,
  event_seq,
  event_ts_ms,
  chain_id,
  environment,
  artifact_id,
  pipeline_run_id,
  run_url,
  actor_name
)
SELECT
  es.organization_id,
  CASE
    WHEN instr(es.subject_id, '/') > 0 THEN substr(es.subject_id, instr(es.subject_id, '/') + 1)
    ELSE es.subject_id
  END AS service_name,
  es.seq,
  es.event_ts_ms,
  es.chain_id,
  COALESCE(NULLIF(json_extract(es.raw_event_json, '$.subject.content.environment.id'), ''), 'unknown') AS environment,
  COALESCE(json_extract(es.raw_event_json, '$.subject.content.artifactId'), '') AS artifact_id,
  COALESCE(json_extract(es.raw_event_json, '$.subject.content.pipeline.runId'), '') AS pipeline_run_id,
  COALESCE(json_extract(es.raw_event_json, '$.subject.content.pipeline.url'), '') AS run_url,
  COALESCE(json_extract(es.raw_event_json, '$.subject.content.actor.name'), '') AS actor_name
FROM event_store es
WHERE es.organization_id = ?1
  AND es.seq = ?2
  AND es.subject_type = 'service'
ON CONFLICT(organization_id, service_name, event_seq) DO NOTHING
`

type UpsertServiceChangeLinkFromEventSeqParams struct {
	OrganizationID int64
	Seq            int64
}

func (q *Queries) UpsertServiceChangeLinkFromEventSeq(ctx context.Context, arg UpsertServiceChangeLinkFromEventSeqParams) error {
	_, err := q.db.ExecContext(ctx, upsertServiceChangeLinkFromEventSeq, arg.OrganizationID, arg.Seq)
	return err
}

const upsertServiceCurrentStateByService = `-- name: UpsertServiceCurrentStateByService :exec
INSERT INTO service_current_state (
  organization_id,
  service_name,
  latest_event_seq,
  latest_event_type,
  latest_event_ts_ms,
  latest_status,
  latest_artifact_id,
  latest_environment,
  drift_count,
  failed_streak
)
SELECT
  ?1,
  ?2,
  ses.latest_event_seq,
  ses.latest_event_type,
  ses.latest_event_ts_ms,
  ses.latest_status,
  ses.latest_artifact_id,
  ses.environment,
  COALESCE((
    SELECT COUNT(DISTINCT NULLIF(se2.latest_artifact_id, ''))
    FROM service_env_state se2
    WHERE se2.organization_id = ?1
      AND se2.service_name = ?2
  ), 0),
  COALESCE((
    SELECT SUM(CASE WHEN se3.latest_status IN ('warning', 'out-of-sync') THEN 1 ELSE 0 END)
    FROM service_env_state se3
    WHERE se3.organization_id = ?1
      AND se3.service_name = ?2
  ), 0)
FROM service_env_state ses
WHERE ses.organization_id = ?1
  AND ses.service_name = ?2
ORDER BY ses.latest_event_ts_ms DESC, ses.latest_event_seq DESC
LIMIT 1
ON CONFLICT(organization_id, service_name) DO UPDATE SET
  latest_event_seq = excluded.latest_event_seq,
  latest_event_type = excluded.latest_event_type,
  latest_event_ts_ms = excluded.latest_event_ts_ms,
  latest_status = excluded.latest_status,
  latest_artifact_id = excluded.latest_artifact_id,
  latest_environment = excluded.latest_environment,
  drift_count = excluded.drift_count,
  failed_streak = excluded.failed_streak,
  updated_at = CURRENT_TIMESTAMP
`

type UpsertServiceCurrentStateByServiceParams struct {
	OrganizationID int64
	ServiceName    string
}

func (q *Queries) UpsertServiceCurrentStateByService(ctx context.Context, arg UpsertServiceCurrentStateByServiceParams) error {
	_, err := q.db.ExecContext(ctx, upsertServiceCurrentStateByService, arg.OrganizationID, arg.ServiceName)
	return err
}

const upsertServiceDeliveryStatsDailyFromEventSeq = `-- name: UpsertServiceDeliveryStatsDailyFromEventSeq :exec
INSERT INTO service_delivery_stats_daily (
  organization_id,
  service_name,
  day_utc,
  deploy_success_count,
  deploy_failure_count,
  rollback_count
)
SELECT
  es.organization_id,
  CASE
    WHEN instr(es.subject_id, '/') > 0 THEN substr(es.subject_id, instr(es.subject_id, '/') + 1)
    ELSE es.subject_id
  END AS service_name,
  date(datetime(es.event_ts_ms / 1000, 'unixepoch')) AS day_utc,
  CASE
    WHEN es.event_type LIKE 'dev.cdevents.service.deployed.%'
      OR es.event_type LIKE 'dev.cdevents.service.upgraded.%'
      OR es.event_type LIKE 'dev.cdevents.service.published.%' THEN 1
    ELSE 0
  END AS deploy_success_count,
  CASE
    WHEN es.event_type LIKE 'dev.cdevents.service.removed.%' THEN 1
    ELSE 0
  END AS deploy_failure_count,
  CASE
    WHEN es.event_type LIKE 'dev.cdevents.service.rolledback.%' THEN 1
    ELSE 0
  END AS rollback_count
FROM event_store es
WHERE es.organization_id = ?1
  AND es.seq = ?2
  AND es.subject_type = 'service'
ON CONFLICT(organization_id, service_name, day_utc) DO UPDATE SET
  deploy_success_count = service_delivery_stats_daily.deploy_success_count + excluded.deploy_success_count,
  deploy_failure_count = service_delivery_stats_daily.deploy_failure_count + excluded.deploy_failure_count,
  rollback_count = service_delivery_stats_daily.rollback_count + excluded.rollback_count,
  updated_at = CURRENT_TIMESTAMP
`

type UpsertServiceDeliveryStatsDailyFromEventSeqParams struct {
	OrganizationID int64
	Seq            int64
}

func (q *Queries) UpsertServiceDeliveryStatsDailyFromEventSeq(ctx context.Context, arg UpsertServiceDeliveryStatsDailyFromEventSeqParams) error {
	_, err := q.db.ExecContext(ctx, upsertServiceDeliveryStatsDailyFromEventSeq, arg.OrganizationID, arg.Seq)
	return err
}

const upsertServiceDependency = `-- name: UpsertServiceDependency :exec
INSERT INTO service_dependencies (organization_id, service_name, depends_on_service_name)
VALUES (?1, ?2, ?3)
ON CONFLICT(organization_id, service_name, depends_on_service_name) DO NOTHING
`

type UpsertServiceDependencyParams struct {
	OrganizationID       int64
	ServiceName          string
	DependsOnServiceName string
}

func (q *Queries) UpsertServiceDependency(ctx context.Context, arg UpsertServiceDependencyParams) error {
	_, err := q.db.ExecContext(ctx, upsertServiceDependency, arg.OrganizationID, arg.ServiceName, arg.DependsOnServiceName)
	return err
}

const upsertServiceEnvStateFromEventSeq = `-- name: UpsertServiceEnvStateFromEventSeq :exec
INSERT INTO service_env_state (
  organization_id,
  service_name,
  environment,
  latest_event_seq,
  latest_event_type,
  latest_event_ts_ms,
  latest_status,
  latest_artifact_id
)
SELECT
  es.organization_id,
  CASE
    WHEN instr(es.subject_id, '/') > 0 THEN substr(es.subject_id, instr(es.subject_id, '/') + 1)
    ELSE es.subject_id
  END AS service_name,
  COALESCE(NULLIF(json_extract(es.raw_event_json, '$.subject.content.environment.id'), ''), 'unknown') AS environment,
  es.seq,
  es.event_type,
  es.event_ts_ms,
  CASE
    WHEN es.event_type LIKE 'dev.cdevents.service.deployed.%' THEN 'synced'
    WHEN es.event_type LIKE 'dev.cdevents.service.upgraded.%' THEN 'synced'
    WHEN es.event_type LIKE 'dev.cdevents.service.published.%' THEN 'synced'
    WHEN es.event_type LIKE 'dev.cdevents.service.rolledback.%' THEN 'warning'
    WHEN es.event_type LIKE 'dev.cdevents.service.removed.%' THEN 'out-of-sync'
    ELSE 'unknown'
  END AS latest_status,
  COALESCE(json_extract(es.raw_event_json, '$.subject.content.artifactId'), '') AS latest_artifact_id
FROM event_store es
WHERE es.organization_id = ?1
  AND es.seq = ?2
  AND es.subject_type = 'service'
ON CONFLICT(organization_id, service_name, environment) DO UPDATE SET
  latest_event_seq = excluded.latest_event_seq,
  latest_event_type = excluded.latest_event_type,
  latest_event_ts_ms = excluded.latest_event_ts_ms,
  latest_status = excluded.latest_status,
  latest_artifact_id = excluded.latest_artifact_id,
  updated_at = CURRENT_TIMESTAMP
WHERE
  excluded.latest_event_ts_ms > service_env_state.latest_event_ts_ms
  OR (excluded.latest_event_ts_ms = service_env_state.latest_event_ts_ms AND excluded.latest_event_seq > service_env_state.latest_event_seq)
`

type UpsertServiceEnvStateFromEventSeqParams struct {
	OrganizationID int64
	Seq            int64
}

func (q *Queries) UpsertServiceEnvStateFromEventSeq(ctx context.Context, arg UpsertServiceEnvStateFromEventSeqParams) error {
	_, err := q.db.ExecContext(ctx, upsertServiceEnvStateFromEventSeq, arg.OrganizationID, arg.Seq)
	return err
}

const upsertServiceMetadata = `-- name: UpsertServiceMetadata :exec
INSERT INTO service_metadata (organization_id, service_name, label, value)
VALUES (?1, ?2, ?3, ?4)
ON CONFLICT(organization_id, service_name, label) DO UPDATE SET
  value = excluded.value,
  updated_at = CURRENT_TIMESTAMP
`

type UpsertServiceMetadataParams struct {
	OrganizationID int64
	ServiceName    string
	Label          string
	Value          string
}

func (q *Queries) UpsertServiceMetadata(ctx context.Context, arg UpsertServiceMetadataParams) error {
	_, err := q.db.ExecContext(ctx, upsertServiceMetadata,
		arg.OrganizationID,
		arg.ServiceName,
		arg.Label,
		arg.Value,
	)
	return err
}

const upsertUser = `-- name: UpsertUser :one
INSERT INTO users (github_id, email, nickname, name, avatar_url)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT(email) DO UPDATE SET
  github_id = excluded.github_id,
  nickname = excluded.nickname,
  name = excluded.name,
  avatar_url = excluded.avatar_url,
  updated_at = CURRENT_TIMESTAMP
RETURNING id, github_id, email, nickname, name, avatar_url, created_at, updated_at
`

type UpsertUserParams struct {
	GithubID  sql.NullString
	Email     string
	Nickname  string
	Name      sql.NullString
	AvatarUrl sql.NullString
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, upsertUser,
		arg.GithubID,
		arg.Email,
		arg.Nickname,
		arg.Name,
		arg.AvatarUrl,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.Email,
		&i.Nickname,
		&i.Name,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
