// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package queries

import (
	"context"
	"database/sql"
)

const appendEventStore = `-- name: AppendEventStore :exec
INSERT INTO event_store (
  organization_id,
  event_id,
  event_type,
  event_source,
  event_timestamp,
  subject_id,
  subject_source,
  subject_type,
  chain_id,
  raw_event_json
)
VALUES (
  ?1,
  ?2,
  ?3,
  ?4,
  ?5,
  ?6,
  ?7,
  ?8,
  ?9,
  ?10
)
ON CONFLICT(organization_id, event_source, event_id) DO NOTHING
`

type AppendEventStoreParams struct {
	OrganizationID int64
	EventID        string
	EventType      string
	EventSource    string
	EventTimestamp string
	SubjectID      string
	SubjectSource  sql.NullString
	SubjectType    string
	ChainID        sql.NullString
	RawEventJson   string
}

func (q *Queries) AppendEventStore(ctx context.Context, arg AppendEventStoreParams) error {
	_, err := q.db.ExecContext(ctx, appendEventStore,
		arg.OrganizationID,
		arg.EventID,
		arg.EventType,
		arg.EventSource,
		arg.EventTimestamp,
		arg.SubjectID,
		arg.SubjectSource,
		arg.SubjectType,
		arg.ChainID,
		arg.RawEventJson,
	)
	return err
}

const countEventStore = `-- name: CountEventStore :one
SELECT COUNT(*)
FROM event_store
`

func (q *Queries) CountEventStore(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEventStore)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventStoreBySubjectType = `-- name: CountEventStoreBySubjectType :one
SELECT COUNT(*)
FROM event_store
WHERE subject_type = ?1
`

func (q *Queries) CountEventStoreBySubjectType(ctx context.Context, subjectType string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEventStoreBySubjectType, subjectType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrganizationOwners = `-- name: CountOrganizationOwners :one
SELECT COUNT(*)
FROM organization_members
WHERE organization_id = ? AND role = 'owner'
`

func (q *Queries) CountOrganizationOwners(ctx context.Context, organizationID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOrganizationOwners, organizationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO organizations (name, auth_token, webhook_secret, enabled)
VALUES (?1, ?2, ?3, ?4)
RETURNING id, name, auth_token, webhook_secret, enabled, created_at, updated_at
`

type CreateOrganizationParams struct {
	Name          string
	AuthToken     string
	WebhookSecret string
	Enabled       int64
}

func (q *Queries) CreateOrganization(ctx context.Context, arg CreateOrganizationParams) (Organization, error) {
	row := q.db.QueryRowContext(ctx, createOrganization,
		arg.Name,
		arg.AuthToken,
		arg.WebhookSecret,
		arg.Enabled,
	)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AuthToken,
		&i.WebhookSecret,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrganizationEnvironmentPriority = `-- name: CreateOrganizationEnvironmentPriority :one
INSERT INTO organization_environment_priorities (organization_id, environment, sort_order)
VALUES (?1, ?2, ?3)
RETURNING id, organization_id, environment, sort_order, created_at, updated_at
`

type CreateOrganizationEnvironmentPriorityParams struct {
	OrganizationID int64
	Environment    string
	SortOrder      int64
}

func (q *Queries) CreateOrganizationEnvironmentPriority(ctx context.Context, arg CreateOrganizationEnvironmentPriorityParams) (OrganizationEnvironmentPriority, error) {
	row := q.db.QueryRowContext(ctx, createOrganizationEnvironmentPriority, arg.OrganizationID, arg.Environment, arg.SortOrder)
	var i OrganizationEnvironmentPriority
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Environment,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrganizationRequiredField = `-- name: CreateOrganizationRequiredField :one
INSERT INTO organization_required_fields (organization_id, label, field_type, sort_order, is_filterable)
VALUES (?1, ?2, ?3, ?4, ?5)
RETURNING id, organization_id, label, field_type, sort_order, created_at, updated_at, is_filterable
`

type CreateOrganizationRequiredFieldParams struct {
	OrganizationID int64
	Label          string
	FieldType      string
	SortOrder      int64
	IsFilterable   int64
}

func (q *Queries) CreateOrganizationRequiredField(ctx context.Context, arg CreateOrganizationRequiredFieldParams) (OrganizationRequiredField, error) {
	row := q.db.QueryRowContext(ctx, createOrganizationRequiredField,
		arg.OrganizationID,
		arg.Label,
		arg.FieldType,
		arg.SortOrder,
		arg.IsFilterable,
	)
	var i OrganizationRequiredField
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Label,
		&i.FieldType,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsFilterable,
	)
	return i, err
}

const deleteOrganization = `-- name: DeleteOrganization :exec
DELETE FROM organizations
WHERE id = ?
`

func (q *Queries) DeleteOrganization(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteOrganization, id)
	return err
}

const deleteOrganizationEnvironmentPriorities = `-- name: DeleteOrganizationEnvironmentPriorities :exec
DELETE FROM organization_environment_priorities
WHERE organization_id = ?
`

func (q *Queries) DeleteOrganizationEnvironmentPriorities(ctx context.Context, organizationID int64) error {
	_, err := q.db.ExecContext(ctx, deleteOrganizationEnvironmentPriorities, organizationID)
	return err
}

const deleteOrganizationMember = `-- name: DeleteOrganizationMember :exec
DELETE FROM organization_members
WHERE organization_id = ? AND user_id = ?
`

type DeleteOrganizationMemberParams struct {
	OrganizationID int64
	UserID         int64
}

func (q *Queries) DeleteOrganizationMember(ctx context.Context, arg DeleteOrganizationMemberParams) error {
	_, err := q.db.ExecContext(ctx, deleteOrganizationMember, arg.OrganizationID, arg.UserID)
	return err
}

const deleteOrganizationRequiredFields = `-- name: DeleteOrganizationRequiredFields :exec
DELETE FROM organization_required_fields
WHERE organization_id = ?
`

func (q *Queries) DeleteOrganizationRequiredFields(ctx context.Context, organizationID int64) error {
	_, err := q.db.ExecContext(ctx, deleteOrganizationRequiredFields, organizationID)
	return err
}

const deleteServiceMetadataByService = `-- name: DeleteServiceMetadataByService :exec
DELETE FROM service_metadata
WHERE organization_id = ?1
  AND service_name = ?2
`

type DeleteServiceMetadataByServiceParams struct {
	OrganizationID int64
	ServiceName    string
}

func (q *Queries) DeleteServiceMetadataByService(ctx context.Context, arg DeleteServiceMetadataByServiceParams) error {
	_, err := q.db.ExecContext(ctx, deleteServiceMetadataByService, arg.OrganizationID, arg.ServiceName)
	return err
}

const getDefaultOrganization = `-- name: GetDefaultOrganization :one
SELECT id, name, auth_token, webhook_secret, enabled, created_at, updated_at
FROM organizations
ORDER BY id
LIMIT 1
`

func (q *Queries) GetDefaultOrganization(ctx context.Context) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getDefaultOrganization)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AuthToken,
		&i.WebhookSecret,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrganizationByAuthToken = `-- name: GetOrganizationByAuthToken :one
SELECT id, name, auth_token, webhook_secret, enabled, created_at, updated_at
FROM organizations
WHERE auth_token = ?
LIMIT 1
`

func (q *Queries) GetOrganizationByAuthToken(ctx context.Context, authToken string) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByAuthToken, authToken)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AuthToken,
		&i.WebhookSecret,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrganizationByID = `-- name: GetOrganizationByID :one
SELECT id, name, auth_token, webhook_secret, enabled, created_at, updated_at
FROM organizations
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetOrganizationByID(ctx context.Context, id int64) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByID, id)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AuthToken,
		&i.WebhookSecret,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrganizationMemberRole = `-- name: GetOrganizationMemberRole :one
SELECT role
FROM organization_members
WHERE organization_id = ? AND user_id = ?
LIMIT 1
`

type GetOrganizationMemberRoleParams struct {
	OrganizationID int64
	UserID         int64
}

func (q *Queries) GetOrganizationMemberRole(ctx context.Context, arg GetOrganizationMemberRoleParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationMemberRole, arg.OrganizationID, arg.UserID)
	var role string
	err := row.Scan(&role)
	return role, err
}

const getServiceLatestFromEvents = `-- name: GetServiceLatestFromEvents :one
SELECT
  CASE
    WHEN instr(es.subject_id, '/') > 0 THEN substr(es.subject_id, instr(es.subject_id, '/') + 1)
    ELSE es.subject_id
  END AS service_name,
  es.subject_id AS raw_subject_id,
  es.event_timestamp AS last_deploy_at,
  'cdevents' AS integration_type
FROM event_store es
WHERE es.subject_type = 'service'
  AND es.organization_id = ?1
  AND (es.subject_id = ?2 OR substr(es.subject_id, instr(es.subject_id, '/') + 1) = ?2)
ORDER BY es.event_timestamp DESC, es.seq DESC
LIMIT 1
`

type GetServiceLatestFromEventsParams struct {
	OrganizationID int64
	Service        string
}

type GetServiceLatestFromEventsRow struct {
	ServiceName     interface{}
	RawSubjectID    string
	LastDeployAt    string
	IntegrationType string
}

func (q *Queries) GetServiceLatestFromEvents(ctx context.Context, arg GetServiceLatestFromEventsParams) (GetServiceLatestFromEventsRow, error) {
	row := q.db.QueryRowContext(ctx, getServiceLatestFromEvents, arg.OrganizationID, arg.Service)
	var i GetServiceLatestFromEventsRow
	err := row.Scan(
		&i.ServiceName,
		&i.RawSubjectID,
		&i.LastDeployAt,
		&i.IntegrationType,
	)
	return i, err
}

const getUserByEmailOrNickname = `-- name: GetUserByEmailOrNickname :one
SELECT id, github_id, email, nickname, name, avatar_url, created_at, updated_at
FROM users
WHERE email = ? OR nickname = ?
LIMIT 1
`

type GetUserByEmailOrNicknameParams struct {
	Email    string
	Nickname string
}

func (q *Queries) GetUserByEmailOrNickname(ctx context.Context, arg GetUserByEmailOrNicknameParams) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmailOrNickname, arg.Email, arg.Nickname)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.Email,
		&i.Nickname,
		&i.Name,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, github_id, email, nickname, name, avatar_url, created_at, updated_at
FROM users
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.Email,
		&i.Nickname,
		&i.Name,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDeploymentHistoryByServiceFromEvents = `-- name: ListDeploymentHistoryByServiceFromEvents :many
SELECT
  es.event_timestamp AS deployed_at,
  COALESCE(json_extract(es.raw_event_json, '$.subject.content.artifactId'), '') AS release_ref,
  COALESCE(NULLIF(json_extract(es.raw_event_json, '$.subject.content.environment.id'), ''), 'unknown') AS environment
FROM event_store es
WHERE es.subject_type = 'service'
  AND es.organization_id = ?1
  AND (es.subject_id = ?2 OR substr(es.subject_id, instr(es.subject_id, '/') + 1) = ?2)
ORDER BY es.event_timestamp DESC, es.seq DESC
LIMIT ?3
`

type ListDeploymentHistoryByServiceFromEventsParams struct {
	OrganizationID int64
	Service        string
	Limit          int64
}

type ListDeploymentHistoryByServiceFromEventsRow struct {
	DeployedAt  string
	ReleaseRef  interface{}
	Environment interface{}
}

func (q *Queries) ListDeploymentHistoryByServiceFromEvents(ctx context.Context, arg ListDeploymentHistoryByServiceFromEventsParams) ([]ListDeploymentHistoryByServiceFromEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, listDeploymentHistoryByServiceFromEvents, arg.OrganizationID, arg.Service, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeploymentHistoryByServiceFromEventsRow
	for rows.Next() {
		var i ListDeploymentHistoryByServiceFromEventsRow
		if err := rows.Scan(&i.DeployedAt, &i.ReleaseRef, &i.Environment); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeploymentsFromEvents = `-- name: ListDeploymentsFromEvents :many
SELECT
  es.event_timestamp AS deployed_at,
  CASE
    WHEN instr(es.subject_id, '/') > 0 THEN substr(es.subject_id, instr(es.subject_id, '/') + 1)
    ELSE es.subject_id
  END AS service,
  COALESCE(NULLIF(json_extract(es.raw_event_json, '$.subject.content.environment.id'), ''), 'unknown') AS environment,
  CASE
    WHEN es.event_type LIKE 'dev.cdevents.service.deployed.%' THEN 'success'
    WHEN es.event_type LIKE 'dev.cdevents.service.upgraded.%' THEN 'success'
    WHEN es.event_type LIKE 'dev.cdevents.service.published.%' THEN 'success'
    WHEN es.event_type LIKE 'dev.cdevents.service.rolledback.%' THEN 'error'
    WHEN es.event_type LIKE 'dev.cdevents.service.removed.%' THEN 'error'
    ELSE 'queued'
  END AS status
FROM event_store es
WHERE es.subject_type = 'service'
  AND es.organization_id = ?1
  AND (?2 = '' OR ?2 = 'all' OR json_extract(es.raw_event_json, '$.subject.content.environment.id') = ?2)
  AND (?3 = '' OR ?3 = 'all' OR es.subject_id = ?3 OR substr(es.subject_id, instr(es.subject_id, '/') + 1) = ?3)
ORDER BY es.event_timestamp DESC, es.seq DESC
`

type ListDeploymentsFromEventsParams struct {
	OrganizationID int64
	Env            interface{}
	Service        interface{}
}

type ListDeploymentsFromEventsRow struct {
	DeployedAt  string
	Service     interface{}
	Environment interface{}
	Status      string
}

func (q *Queries) ListDeploymentsFromEvents(ctx context.Context, arg ListDeploymentsFromEventsParams) ([]ListDeploymentsFromEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, listDeploymentsFromEvents, arg.OrganizationID, arg.Env, arg.Service)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeploymentsFromEventsRow
	for rows.Next() {
		var i ListDeploymentsFromEventsRow
		if err := rows.Scan(
			&i.DeployedAt,
			&i.Service,
			&i.Environment,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDistinctServiceEnvironmentsFromEvents = `-- name: ListDistinctServiceEnvironmentsFromEvents :many
SELECT DISTINCT COALESCE(NULLIF(json_extract(es.raw_event_json, '$.subject.content.environment.id'), ''), 'unknown') AS environment
FROM event_store es
WHERE es.organization_id = ?1
  AND es.subject_type = 'service'
ORDER BY environment
`

func (q *Queries) ListDistinctServiceEnvironmentsFromEvents(ctx context.Context, organizationID int64) ([]interface{}, error) {
	rows, err := q.db.QueryContext(ctx, listDistinctServiceEnvironmentsFromEvents, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var environment interface{}
		if err := rows.Scan(&environment); err != nil {
			return nil, err
		}
		items = append(items, environment)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLegacyDeploymentsForBackfill = `-- name: ListLegacyDeploymentsForBackfill :many
SELECT
  d.id,
  d.deployed_at,
  s.name AS service,
  e.name AS environment,
  d.status,
  d.release_ref
FROM deployments d
JOIN services s ON s.id = d.service_id
JOIN environments e ON e.id = d.environment_id
ORDER BY d.id
`

type ListLegacyDeploymentsForBackfillRow struct {
	ID          int64
	DeployedAt  string
	Service     string
	Environment string
	Status      string
	ReleaseRef  sql.NullString
}

func (q *Queries) ListLegacyDeploymentsForBackfill(ctx context.Context) ([]ListLegacyDeploymentsForBackfillRow, error) {
	rows, err := q.db.QueryContext(ctx, listLegacyDeploymentsForBackfill)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLegacyDeploymentsForBackfillRow
	for rows.Next() {
		var i ListLegacyDeploymentsForBackfillRow
		if err := rows.Scan(
			&i.ID,
			&i.DeployedAt,
			&i.Service,
			&i.Environment,
			&i.Status,
			&i.ReleaseRef,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationEnvironmentPriorities = `-- name: ListOrganizationEnvironmentPriorities :many
SELECT id, organization_id, environment, sort_order
FROM organization_environment_priorities
WHERE organization_id = ?
ORDER BY sort_order, id
`

type ListOrganizationEnvironmentPrioritiesRow struct {
	ID             int64
	OrganizationID int64
	Environment    string
	SortOrder      int64
}

func (q *Queries) ListOrganizationEnvironmentPriorities(ctx context.Context, organizationID int64) ([]ListOrganizationEnvironmentPrioritiesRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationEnvironmentPriorities, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrganizationEnvironmentPrioritiesRow
	for rows.Next() {
		var i ListOrganizationEnvironmentPrioritiesRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Environment,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationFeatures = `-- name: ListOrganizationFeatures :many
SELECT feature_key, is_enabled
FROM organization_features
WHERE organization_id = ?
ORDER BY feature_key
`

type ListOrganizationFeaturesRow struct {
	FeatureKey string
	IsEnabled  int64
}

func (q *Queries) ListOrganizationFeatures(ctx context.Context, organizationID int64) ([]ListOrganizationFeaturesRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationFeatures, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrganizationFeaturesRow
	for rows.Next() {
		var i ListOrganizationFeaturesRow
		if err := rows.Scan(&i.FeatureKey, &i.IsEnabled); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationMembers = `-- name: ListOrganizationMembers :many
SELECT
  u.id AS user_id,
  u.email,
  u.nickname,
  u.name,
  u.avatar_url,
  m.role
FROM organization_members m
JOIN users u ON u.id = m.user_id
WHERE m.organization_id = ?
ORDER BY
  CASE m.role WHEN 'owner' THEN 0 WHEN 'admin' THEN 1 ELSE 2 END,
  COALESCE(NULLIF(u.name, ''), u.nickname, u.email)
`

type ListOrganizationMembersRow struct {
	UserID    int64
	Email     string
	Nickname  string
	Name      sql.NullString
	AvatarUrl sql.NullString
	Role      string
}

func (q *Queries) ListOrganizationMembers(ctx context.Context, organizationID int64) ([]ListOrganizationMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationMembers, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrganizationMembersRow
	for rows.Next() {
		var i ListOrganizationMembersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.Nickname,
			&i.Name,
			&i.AvatarUrl,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationPreferences = `-- name: ListOrganizationPreferences :many
SELECT preference_key, preference_value
FROM organization_preferences
WHERE organization_id = ?
ORDER BY preference_key
`

type ListOrganizationPreferencesRow struct {
	PreferenceKey   string
	PreferenceValue string
}

func (q *Queries) ListOrganizationPreferences(ctx context.Context, organizationID int64) ([]ListOrganizationPreferencesRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationPreferences, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrganizationPreferencesRow
	for rows.Next() {
		var i ListOrganizationPreferencesRow
		if err := rows.Scan(&i.PreferenceKey, &i.PreferenceValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationRequiredFields = `-- name: ListOrganizationRequiredFields :many
SELECT id, organization_id, label, field_type, sort_order, is_filterable
FROM organization_required_fields
WHERE organization_id = ?
ORDER BY sort_order, id
`

type ListOrganizationRequiredFieldsRow struct {
	ID             int64
	OrganizationID int64
	Label          string
	FieldType      string
	SortOrder      int64
	IsFilterable   int64
}

func (q *Queries) ListOrganizationRequiredFields(ctx context.Context, organizationID int64) ([]ListOrganizationRequiredFieldsRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationRequiredFields, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrganizationRequiredFieldsRow
	for rows.Next() {
		var i ListOrganizationRequiredFieldsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Label,
			&i.FieldType,
			&i.SortOrder,
			&i.IsFilterable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizations = `-- name: ListOrganizations :many
SELECT id, name, auth_token, webhook_secret, enabled, created_at, updated_at
FROM organizations
ORDER BY name, id
`

func (q *Queries) ListOrganizations(ctx context.Context) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AuthToken,
			&i.WebhookSecret,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationsByUser = `-- name: ListOrganizationsByUser :many
SELECT o.id, o.name, o.auth_token, o.webhook_secret, o.enabled, o.created_at, o.updated_at
FROM organizations o
JOIN organization_members m ON m.organization_id = o.id
WHERE m.user_id = ?
ORDER BY o.name, o.id
`

func (q *Queries) ListOrganizationsByUser(ctx context.Context, userID int64) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AuthToken,
			&i.WebhookSecret,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceEnvironmentsFromEvents = `-- name: ListServiceEnvironmentsFromEvents :many
WITH service_events AS (
  SELECT
    es.seq,
    COALESCE(NULLIF(json_extract(es.raw_event_json, '$.subject.content.environment.id'), ''), 'unknown') AS environment,
    es.event_timestamp,
    COALESCE(json_extract(es.raw_event_json, '$.subject.content.artifactId'), '') AS artifact_id
  FROM event_store es
  WHERE es.subject_type = 'service'
    AND es.organization_id = ?1
    AND (es.subject_id = ?2 OR substr(es.subject_id, instr(es.subject_id, '/') + 1) = ?2)
), ranked AS (
  SELECT
    environment,
    event_timestamp,
    artifact_id,
    row_number() OVER (
      PARTITION BY environment
      ORDER BY event_timestamp DESC, seq DESC
    ) AS rn
  FROM service_events
)
SELECT
  environment AS name,
  event_timestamp AS released_at,
  artifact_id AS ref
FROM ranked
WHERE rn = 1
ORDER BY released_at DESC
`

type ListServiceEnvironmentsFromEventsParams struct {
	OrganizationID int64
	Service        string
}

type ListServiceEnvironmentsFromEventsRow struct {
	Name       interface{}
	ReleasedAt string
	Ref        interface{}
}

func (q *Queries) ListServiceEnvironmentsFromEvents(ctx context.Context, arg ListServiceEnvironmentsFromEventsParams) ([]ListServiceEnvironmentsFromEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, listServiceEnvironmentsFromEvents, arg.OrganizationID, arg.Service)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListServiceEnvironmentsFromEventsRow
	for rows.Next() {
		var i ListServiceEnvironmentsFromEventsRow
		if err := rows.Scan(&i.Name, &i.ReleasedAt, &i.Ref); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceInstancesByEnvFromEvents = `-- name: ListServiceInstancesByEnvFromEvents :many
WITH service_events AS (
  SELECT
    es.seq,
    es.event_type,
    es.event_timestamp,
    CASE
      WHEN instr(es.subject_id, '/') > 0 THEN substr(es.subject_id, instr(es.subject_id, '/') + 1)
      ELSE es.subject_id
    END AS service_name,
    COALESCE(NULLIF(json_extract(es.raw_event_json, '$.subject.content.environment.id'), ''), 'unknown') AS environment,
    COALESCE(json_extract(es.raw_event_json, '$.subject.content.artifactId'), '') AS artifact_id,
    CASE
      WHEN es.event_type LIKE 'dev.cdevents.service.deployed.%' THEN 'synced'
      WHEN es.event_type LIKE 'dev.cdevents.service.upgraded.%' THEN 'synced'
      WHEN es.event_type LIKE 'dev.cdevents.service.published.%' THEN 'synced'
      WHEN es.event_type LIKE 'dev.cdevents.service.rolledback.%' THEN 'warning'
      WHEN es.event_type LIKE 'dev.cdevents.service.removed.%' THEN 'out-of-sync'
      ELSE 'unknown'
    END AS status
  FROM event_store es
  WHERE es.subject_type = 'service'
    AND es.organization_id = ?1
    AND COALESCE(NULLIF(json_extract(es.raw_event_json, '$.subject.content.environment.id'), ''), 'unknown') = ?2
), ranked AS (
  SELECT
    service_name,
    environment,
    status,
    event_timestamp,
    artifact_id,
    row_number() OVER (
      PARTITION BY service_name
      ORDER BY event_timestamp DESC, seq DESC
    ) AS rn
  FROM service_events
)
SELECT
  service_name,
  environment,
  status,
  event_timestamp AS last_deploy_at,
  artifact_id
FROM ranked
WHERE rn = 1
ORDER BY service_name, environment
`

type ListServiceInstancesByEnvFromEventsParams struct {
	OrganizationID int64
	Env            string
}

type ListServiceInstancesByEnvFromEventsRow struct {
	ServiceName  interface{}
	Environment  interface{}
	Status       string
	LastDeployAt string
	ArtifactID   interface{}
}

func (q *Queries) ListServiceInstancesByEnvFromEvents(ctx context.Context, arg ListServiceInstancesByEnvFromEventsParams) ([]ListServiceInstancesByEnvFromEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, listServiceInstancesByEnvFromEvents, arg.OrganizationID, arg.Env)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListServiceInstancesByEnvFromEventsRow
	for rows.Next() {
		var i ListServiceInstancesByEnvFromEventsRow
		if err := rows.Scan(
			&i.ServiceName,
			&i.Environment,
			&i.Status,
			&i.LastDeployAt,
			&i.ArtifactID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceInstancesFromEvents = `-- name: ListServiceInstancesFromEvents :many
WITH service_events AS (
  SELECT
    es.seq,
    es.event_type,
    es.event_timestamp,
    CASE
      WHEN instr(es.subject_id, '/') > 0 THEN substr(es.subject_id, instr(es.subject_id, '/') + 1)
      ELSE es.subject_id
    END AS service_name,
    COALESCE(NULLIF(json_extract(es.raw_event_json, '$.subject.content.environment.id'), ''), 'unknown') AS environment,
    COALESCE(json_extract(es.raw_event_json, '$.subject.content.artifactId'), '') AS artifact_id,
    CASE
      WHEN es.event_type LIKE 'dev.cdevents.service.deployed.%' THEN 'synced'
      WHEN es.event_type LIKE 'dev.cdevents.service.upgraded.%' THEN 'synced'
      WHEN es.event_type LIKE 'dev.cdevents.service.published.%' THEN 'synced'
      WHEN es.event_type LIKE 'dev.cdevents.service.rolledback.%' THEN 'warning'
      WHEN es.event_type LIKE 'dev.cdevents.service.removed.%' THEN 'out-of-sync'
      ELSE 'unknown'
    END AS status
  FROM event_store es
  WHERE es.subject_type = 'service'
    AND es.organization_id = ?1
), ranked AS (
  SELECT
    service_name,
    environment,
    status,
    event_timestamp,
    artifact_id,
    row_number() OVER (
      PARTITION BY service_name
      ORDER BY event_timestamp DESC, seq DESC
    ) AS rn
  FROM service_events
)
SELECT
  service_name,
  environment,
  status,
  event_timestamp AS last_deploy_at,
  artifact_id
FROM ranked
WHERE rn = 1
ORDER BY service_name, environment
`

type ListServiceInstancesFromEventsRow struct {
	ServiceName  interface{}
	Environment  interface{}
	Status       string
	LastDeployAt string
	ArtifactID   interface{}
}

func (q *Queries) ListServiceInstancesFromEvents(ctx context.Context, organizationID int64) ([]ListServiceInstancesFromEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, listServiceInstancesFromEvents, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListServiceInstancesFromEventsRow
	for rows.Next() {
		var i ListServiceInstancesFromEventsRow
		if err := rows.Scan(
			&i.ServiceName,
			&i.Environment,
			&i.Status,
			&i.LastDeployAt,
			&i.ArtifactID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceMetadataByOrganization = `-- name: ListServiceMetadataByOrganization :many
SELECT service_name, label, value
FROM service_metadata
WHERE organization_id = ?1
ORDER BY service_name, label
`

type ListServiceMetadataByOrganizationRow struct {
	ServiceName string
	Label       string
	Value       string
}

func (q *Queries) ListServiceMetadataByOrganization(ctx context.Context, organizationID int64) ([]ListServiceMetadataByOrganizationRow, error) {
	rows, err := q.db.QueryContext(ctx, listServiceMetadataByOrganization, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListServiceMetadataByOrganizationRow
	for rows.Next() {
		var i ListServiceMetadataByOrganizationRow
		if err := rows.Scan(&i.ServiceName, &i.Label, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceMetadataByService = `-- name: ListServiceMetadataByService :many
SELECT label, value
FROM service_metadata
WHERE organization_id = ?1
  AND service_name = ?2
ORDER BY label
`

type ListServiceMetadataByServiceParams struct {
	OrganizationID int64
	ServiceName    string
}

type ListServiceMetadataByServiceRow struct {
	Label string
	Value string
}

func (q *Queries) ListServiceMetadataByService(ctx context.Context, arg ListServiceMetadataByServiceParams) ([]ListServiceMetadataByServiceRow, error) {
	rows, err := q.db.QueryContext(ctx, listServiceMetadataByService, arg.OrganizationID, arg.ServiceName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListServiceMetadataByServiceRow
	for rows.Next() {
		var i ListServiceMetadataByServiceRow
		if err := rows.Scan(&i.Label, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrganizationEnabled = `-- name: UpdateOrganizationEnabled :exec
UPDATE organizations
SET enabled = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateOrganizationEnabledParams struct {
	Enabled int64
	ID      int64
}

func (q *Queries) UpdateOrganizationEnabled(ctx context.Context, arg UpdateOrganizationEnabledParams) error {
	_, err := q.db.ExecContext(ctx, updateOrganizationEnabled, arg.Enabled, arg.ID)
	return err
}

const updateOrganizationName = `-- name: UpdateOrganizationName :exec
UPDATE organizations
SET name = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateOrganizationNameParams struct {
	Name string
	ID   int64
}

func (q *Queries) UpdateOrganizationName(ctx context.Context, arg UpdateOrganizationNameParams) error {
	_, err := q.db.ExecContext(ctx, updateOrganizationName, arg.Name, arg.ID)
	return err
}

const updateOrganizationSecrets = `-- name: UpdateOrganizationSecrets :exec
UPDATE organizations
SET auth_token = ?, webhook_secret = ?, enabled = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateOrganizationSecretsParams struct {
	AuthToken     string
	WebhookSecret string
	Enabled       int64
	ID            int64
}

func (q *Queries) UpdateOrganizationSecrets(ctx context.Context, arg UpdateOrganizationSecretsParams) error {
	_, err := q.db.ExecContext(ctx, updateOrganizationSecrets,
		arg.AuthToken,
		arg.WebhookSecret,
		arg.Enabled,
		arg.ID,
	)
	return err
}

const upsertOrganizationFeature = `-- name: UpsertOrganizationFeature :exec
INSERT INTO organization_features (organization_id, feature_key, is_enabled)
VALUES (?, ?, ?)
ON CONFLICT(organization_id, feature_key) DO UPDATE SET
  is_enabled = excluded.is_enabled,
  updated_at = CURRENT_TIMESTAMP
`

type UpsertOrganizationFeatureParams struct {
	OrganizationID int64
	FeatureKey     string
	IsEnabled      int64
}

func (q *Queries) UpsertOrganizationFeature(ctx context.Context, arg UpsertOrganizationFeatureParams) error {
	_, err := q.db.ExecContext(ctx, upsertOrganizationFeature, arg.OrganizationID, arg.FeatureKey, arg.IsEnabled)
	return err
}

const upsertOrganizationMember = `-- name: UpsertOrganizationMember :exec
INSERT INTO organization_members (organization_id, user_id, role)
VALUES (?, ?, ?)
ON CONFLICT(organization_id, user_id) DO UPDATE SET
  role = excluded.role,
  updated_at = CURRENT_TIMESTAMP
`

type UpsertOrganizationMemberParams struct {
	OrganizationID int64
	UserID         int64
	Role           string
}

func (q *Queries) UpsertOrganizationMember(ctx context.Context, arg UpsertOrganizationMemberParams) error {
	_, err := q.db.ExecContext(ctx, upsertOrganizationMember, arg.OrganizationID, arg.UserID, arg.Role)
	return err
}

const upsertOrganizationPreference = `-- name: UpsertOrganizationPreference :exec
INSERT INTO organization_preferences (organization_id, preference_key, preference_value)
VALUES (?, ?, ?)
ON CONFLICT(organization_id, preference_key) DO UPDATE SET
  preference_value = excluded.preference_value,
  updated_at = CURRENT_TIMESTAMP
`

type UpsertOrganizationPreferenceParams struct {
	OrganizationID  int64
	PreferenceKey   string
	PreferenceValue string
}

func (q *Queries) UpsertOrganizationPreference(ctx context.Context, arg UpsertOrganizationPreferenceParams) error {
	_, err := q.db.ExecContext(ctx, upsertOrganizationPreference, arg.OrganizationID, arg.PreferenceKey, arg.PreferenceValue)
	return err
}

const upsertServiceMetadata = `-- name: UpsertServiceMetadata :exec
INSERT INTO service_metadata (organization_id, service_name, label, value)
VALUES (?1, ?2, ?3, ?4)
ON CONFLICT(organization_id, service_name, label) DO UPDATE SET
  value = excluded.value,
  updated_at = CURRENT_TIMESTAMP
`

type UpsertServiceMetadataParams struct {
	OrganizationID int64
	ServiceName    string
	Label          string
	Value          string
}

func (q *Queries) UpsertServiceMetadata(ctx context.Context, arg UpsertServiceMetadataParams) error {
	_, err := q.db.ExecContext(ctx, upsertServiceMetadata,
		arg.OrganizationID,
		arg.ServiceName,
		arg.Label,
		arg.Value,
	)
	return err
}

const upsertUser = `-- name: UpsertUser :one
INSERT INTO users (github_id, email, nickname, name, avatar_url)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT(email) DO UPDATE SET
  github_id = excluded.github_id,
  nickname = excluded.nickname,
  name = excluded.name,
  avatar_url = excluded.avatar_url,
  updated_at = CURRENT_TIMESTAMP
RETURNING id, github_id, email, nickname, name, avatar_url, created_at, updated_at
`

type UpsertUserParams struct {
	GithubID  sql.NullString
	Email     string
	Nickname  string
	Name      sql.NullString
	AvatarUrl sql.NullString
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, upsertUser,
		arg.GithubID,
		arg.Email,
		arg.Nickname,
		arg.Name,
		arg.AvatarUrl,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.Email,
		&i.Nickname,
		&i.Name,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
