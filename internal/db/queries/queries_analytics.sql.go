// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries_analytics.sql

package queries

import (
	"context"
	"database/sql"
)

const countEventStore = `-- name: CountEventStore :one
SELECT COUNT(*)
FROM event_store
`

func (q *Queries) CountEventStore(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEventStore)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventStoreByOrganization = `-- name: CountEventStoreByOrganization :one
SELECT COUNT(*)
FROM event_store
WHERE organization_id = ?1
`

func (q *Queries) CountEventStoreByOrganization(ctx context.Context, organizationID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEventStoreByOrganization, organizationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventStoreByOrganizationSinceMs = `-- name: CountEventStoreByOrganizationSinceMs :one
SELECT COUNT(*)
FROM event_store
WHERE organization_id = ?1
  AND event_ts_ms >= ?2
`

type CountEventStoreByOrganizationSinceMsParams struct {
	OrganizationID int64
	SinceMs        int64
}

func (q *Queries) CountEventStoreByOrganizationSinceMs(ctx context.Context, arg CountEventStoreByOrganizationSinceMsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEventStoreByOrganizationSinceMs, arg.OrganizationID, arg.SinceMs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventStoreBySubjectType = `-- name: CountEventStoreBySubjectType :one
SELECT COUNT(*)
FROM event_store
WHERE subject_type = ?1
`

func (q *Queries) CountEventStoreBySubjectType(ctx context.Context, subjectType string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEventStoreBySubjectType, subjectType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getServiceCurrentState = `-- name: GetServiceCurrentState :one
SELECT
  latest_status,
  latest_event_ts_ms,
  drift_count,
  failed_streak
FROM service_current_state
WHERE organization_id = ?1
  AND service_name = ?2
LIMIT 1
`

type GetServiceCurrentStateParams struct {
	OrganizationID int64
	ServiceName    string
}

type GetServiceCurrentStateRow struct {
	LatestStatus    string
	LatestEventTsMs int64
	DriftCount      int64
	FailedStreak    int64
}

func (q *Queries) GetServiceCurrentState(ctx context.Context, arg GetServiceCurrentStateParams) (GetServiceCurrentStateRow, error) {
	row := q.db.QueryRowContext(ctx, getServiceCurrentState, arg.OrganizationID, arg.ServiceName)
	var i GetServiceCurrentStateRow
	err := row.Scan(
		&i.LatestStatus,
		&i.LatestEventTsMs,
		&i.DriftCount,
		&i.FailedStreak,
	)
	return i, err
}

const getServiceDeliveryStats30d = `-- name: GetServiceDeliveryStats30d :one
SELECT
  COALESCE(SUM(deploy_success_count), 0) AS deploy_success_count,
  COALESCE(SUM(deploy_failure_count), 0) AS deploy_failure_count,
  COALESCE(SUM(rollback_count), 0) AS rollback_count
FROM service_delivery_stats_daily
WHERE organization_id = ?1
  AND service_name = ?2
  AND day_utc >= date('now', '-30 day')
`

type GetServiceDeliveryStats30dParams struct {
	OrganizationID int64
	ServiceName    string
}

type GetServiceDeliveryStats30dRow struct {
	DeploySuccessCount interface{}
	DeployFailureCount interface{}
	RollbackCount      interface{}
}

func (q *Queries) GetServiceDeliveryStats30d(ctx context.Context, arg GetServiceDeliveryStats30dParams) (GetServiceDeliveryStats30dRow, error) {
	row := q.db.QueryRowContext(ctx, getServiceDeliveryStats30d, arg.OrganizationID, arg.ServiceName)
	var i GetServiceDeliveryStats30dRow
	err := row.Scan(&i.DeploySuccessCount, &i.DeployFailureCount, &i.RollbackCount)
	return i, err
}

const listEventStoreDailyVolume = `-- name: ListEventStoreDailyVolume :many
SELECT
  date(datetime(event_ts_ms / 1000, 'unixepoch')) AS day,
  COUNT(*) AS total
FROM event_store
WHERE organization_id = ?1
  AND event_ts_ms >= ?2
GROUP BY day
ORDER BY day DESC
LIMIT ?3
`

type ListEventStoreDailyVolumeParams struct {
	OrganizationID int64
	SinceMs        int64
	Limit          int64
}

type ListEventStoreDailyVolumeRow struct {
	Day   interface{}
	Total int64
}

func (q *Queries) ListEventStoreDailyVolume(ctx context.Context, arg ListEventStoreDailyVolumeParams) ([]ListEventStoreDailyVolumeRow, error) {
	rows, err := q.db.QueryContext(ctx, listEventStoreDailyVolume, arg.OrganizationID, arg.SinceMs, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEventStoreDailyVolumeRow
	for rows.Next() {
		var i ListEventStoreDailyVolumeRow
		if err := rows.Scan(&i.Day, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceChangeLinksRecent = `-- name: ListServiceChangeLinksRecent :many
SELECT
  event_ts_ms,
  chain_id,
  environment,
  artifact_id,
  pipeline_run_id,
  run_url,
  actor_name
FROM service_change_links
WHERE organization_id = ?1
  AND service_name = ?2
ORDER BY event_ts_ms DESC
LIMIT ?3
`

type ListServiceChangeLinksRecentParams struct {
	OrganizationID int64
	ServiceName    string
	Limit          int64
}

type ListServiceChangeLinksRecentRow struct {
	EventTsMs     int64
	ChainID       sql.NullString
	Environment   string
	ArtifactID    string
	PipelineRunID string
	RunUrl        string
	ActorName     string
}

func (q *Queries) ListServiceChangeLinksRecent(ctx context.Context, arg ListServiceChangeLinksRecentParams) ([]ListServiceChangeLinksRecentRow, error) {
	rows, err := q.db.QueryContext(ctx, listServiceChangeLinksRecent, arg.OrganizationID, arg.ServiceName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListServiceChangeLinksRecentRow
	for rows.Next() {
		var i ListServiceChangeLinksRecentRow
		if err := rows.Scan(
			&i.EventTsMs,
			&i.ChainID,
			&i.Environment,
			&i.ArtifactID,
			&i.PipelineRunID,
			&i.RunUrl,
			&i.ActorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
