// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries_analytics.sql

package queries

import (
	"context"
	"database/sql"
)

const countEventStore = `-- name: CountEventStore :one
SELECT COUNT(*)
FROM event_store
`

func (q *Queries) CountEventStore(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEventStore)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventStoreByOrganization = `-- name: CountEventStoreByOrganization :one
SELECT COUNT(*)
FROM event_store
WHERE organization_id = ?1
`

func (q *Queries) CountEventStoreByOrganization(ctx context.Context, organizationID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEventStoreByOrganization, organizationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventStoreByOrganizationSinceMs = `-- name: CountEventStoreByOrganizationSinceMs :one
SELECT COUNT(*)
FROM event_store
WHERE organization_id = ?1
  AND event_ts_ms >= ?2
`

type CountEventStoreByOrganizationSinceMsParams struct {
	OrganizationID int64
	SinceMs        int64
}

func (q *Queries) CountEventStoreByOrganizationSinceMs(ctx context.Context, arg CountEventStoreByOrganizationSinceMsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEventStoreByOrganizationSinceMs, arg.OrganizationID, arg.SinceMs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventStoreBySubjectType = `-- name: CountEventStoreBySubjectType :one
SELECT COUNT(*)
FROM event_store
WHERE subject_type = ?1
`

func (q *Queries) CountEventStoreBySubjectType(ctx context.Context, subjectType string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEventStoreBySubjectType, subjectType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getServiceCurrentState = `-- name: GetServiceCurrentState :one
SELECT
  latest_status,
  latest_event_ts_ms,
  drift_count,
  failed_streak
FROM service_current_state
WHERE organization_id = ?1
  AND service_name = ?2
LIMIT 1
`

type GetServiceCurrentStateParams struct {
	OrganizationID int64
	ServiceName    string
}

type GetServiceCurrentStateRow struct {
	LatestStatus    string
	LatestEventTsMs int64
	DriftCount      int64
	FailedStreak    int64
}

func (q *Queries) GetServiceCurrentState(ctx context.Context, arg GetServiceCurrentStateParams) (GetServiceCurrentStateRow, error) {
	row := q.db.QueryRowContext(ctx, getServiceCurrentState, arg.OrganizationID, arg.ServiceName)
	var i GetServiceCurrentStateRow
	err := row.Scan(
		&i.LatestStatus,
		&i.LatestEventTsMs,
		&i.DriftCount,
		&i.FailedStreak,
	)
	return i, err
}

const getServiceDeliveryStats30d = `-- name: GetServiceDeliveryStats30d :one
SELECT
  COALESCE(SUM(deploy_success_count), 0) AS deploy_success_count,
  COALESCE(SUM(deploy_failure_count), 0) AS deploy_failure_count,
  COALESCE(SUM(rollback_count), 0) AS rollback_count
FROM service_delivery_stats_daily
WHERE organization_id = ?1
  AND service_name = ?2
  AND day_utc >= date('now', '-30 day')
`

type GetServiceDeliveryStats30dParams struct {
	OrganizationID int64
	ServiceName    string
}

type GetServiceDeliveryStats30dRow struct {
	DeploySuccessCount interface{}
	DeployFailureCount interface{}
	RollbackCount      interface{}
}

func (q *Queries) GetServiceDeliveryStats30d(ctx context.Context, arg GetServiceDeliveryStats30dParams) (GetServiceDeliveryStats30dRow, error) {
	row := q.db.QueryRowContext(ctx, getServiceDeliveryStats30d, arg.OrganizationID, arg.ServiceName)
	var i GetServiceDeliveryStats30dRow
	err := row.Scan(&i.DeploySuccessCount, &i.DeployFailureCount, &i.RollbackCount)
	return i, err
}

const listEventStoreDailyVolume = `-- name: ListEventStoreDailyVolume :many
SELECT
  date(datetime(event_ts_ms / 1000, 'unixepoch')) AS day,
  COUNT(*) AS total
FROM event_store
WHERE organization_id = ?1
  AND event_ts_ms >= ?2
GROUP BY day
ORDER BY day DESC
LIMIT ?3
`

type ListEventStoreDailyVolumeParams struct {
	OrganizationID int64
	SinceMs        int64
	Limit          int64
}

type ListEventStoreDailyVolumeRow struct {
	Day   interface{}
	Total int64
}

func (q *Queries) ListEventStoreDailyVolume(ctx context.Context, arg ListEventStoreDailyVolumeParams) ([]ListEventStoreDailyVolumeRow, error) {
	rows, err := q.db.QueryContext(ctx, listEventStoreDailyVolume, arg.OrganizationID, arg.SinceMs, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEventStoreDailyVolumeRow
	for rows.Next() {
		var i ListEventStoreDailyVolumeRow
		if err := rows.Scan(&i.Day, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceChangeLinksRecent = `-- name: ListServiceChangeLinksRecent :many
SELECT
  event_ts_ms,
  chain_id,
  environment,
  artifact_id,
  pipeline_run_id,
  run_url,
  actor_name
FROM service_change_links
WHERE organization_id = ?1
  AND service_name = ?2
ORDER BY event_ts_ms DESC
LIMIT ?3
`

type ListServiceChangeLinksRecentParams struct {
	OrganizationID int64
	ServiceName    string
	Limit          int64
}

type ListServiceChangeLinksRecentRow struct {
	EventTsMs     int64
	ChainID       sql.NullString
	Environment   string
	ArtifactID    string
	PipelineRunID string
	RunUrl        string
	ActorName     string
}

func (q *Queries) ListServiceChangeLinksRecent(ctx context.Context, arg ListServiceChangeLinksRecentParams) ([]ListServiceChangeLinksRecentRow, error) {
	rows, err := q.db.QueryContext(ctx, listServiceChangeLinksRecent, arg.OrganizationID, arg.ServiceName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListServiceChangeLinksRecentRow
	for rows.Next() {
		var i ListServiceChangeLinksRecentRow
		if err := rows.Scan(
			&i.EventTsMs,
			&i.ChainID,
			&i.Environment,
			&i.ArtifactID,
			&i.PipelineRunID,
			&i.RunUrl,
			&i.ActorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceLeadTimeSamplesFromEvents = `-- name: ListServiceLeadTimeSamplesFromEvents :many
WITH deploy_events AS (
  SELECT
    es.event_ts_ms AS deploy_ts_ms,
    date(datetime(es.event_ts_ms / 1000, 'unixepoch')) AS day_utc,
    CASE
      WHEN instr(es.subject_id, '/') > 0 THEN substr(es.subject_id, instr(es.subject_id, '/') + 1)
      ELSE es.subject_id
    END AS service_name
  FROM event_store es
  WHERE es.organization_id = ?1
    AND es.subject_type = 'service'
    AND es.event_type LIKE 'dev.cdevents.service.deployed.%'
    AND es.event_ts_ms >= ?2
), change_events AS (
  SELECT
    es.event_ts_ms AS change_ts_ms,
    CASE
      WHEN instr(json_extract(es.raw_event_json, '$.subject.content.artifactId'), 'pkg:generic/') = 1
       AND instr(substr(json_extract(es.raw_event_json, '$.subject.content.artifactId'), 13), '@') > 0
      THEN substr(
        json_extract(es.raw_event_json, '$.subject.content.artifactId'),
        13,
        instr(substr(json_extract(es.raw_event_json, '$.subject.content.artifactId'), 13), '@') - 1
      )
      ELSE ''
    END AS service_name
  FROM event_store es
  WHERE es.organization_id = ?1
    AND es.subject_type = 'change'
    AND es.event_ts_ms >= ?2
)
SELECT day_utc, service_name, lead_seconds
FROM (
  SELECT
    d.day_utc,
    d.service_name,
    (d.deploy_ts_ms - (
      SELECT MAX(c.change_ts_ms)
      FROM change_events c
      WHERE c.service_name = d.service_name
        AND c.change_ts_ms <= d.deploy_ts_ms
    )) / 1000 AS lead_seconds
  FROM deploy_events d
  WHERE d.service_name != ''
)
WHERE lead_seconds IS NOT NULL
  AND lead_seconds >= 0
ORDER BY day_utc DESC, service_name ASC, lead_seconds ASC
`

type ListServiceLeadTimeSamplesFromEventsParams struct {
	OrganizationID int64
	SinceMs        int64
}

type ListServiceLeadTimeSamplesFromEventsRow struct {
	DayUtc      interface{}
	ServiceName interface{}
	LeadSeconds int64
}

func (q *Queries) ListServiceLeadTimeSamplesFromEvents(ctx context.Context, arg ListServiceLeadTimeSamplesFromEventsParams) ([]ListServiceLeadTimeSamplesFromEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, listServiceLeadTimeSamplesFromEvents, arg.OrganizationID, arg.SinceMs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListServiceLeadTimeSamplesFromEventsRow
	for rows.Next() {
		var i ListServiceLeadTimeSamplesFromEventsRow
		if err := rows.Scan(&i.DayUtc, &i.ServiceName, &i.LeadSeconds); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
