package main

import (
	"bytes"
	"context"
	"embed"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/a-h/templ"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"

	slogecho "github.com/samber/slog-echo"

	"github.com/fr0stylo/ddash/views/components"
	"github.com/fr0stylo/ddash/views/pages"
)

//go:embed ../../public
var publicFS embed.FS

func main() {
	log := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
		Level: slog.LevelInfo,
	}))

	slog.SetDefault(log)

	e := echo.New()
	defer e.Shutdown(nil) //nolint:errcheck

	e.Renderer = &Template{}
	e.HideBanner = true
	e.HidePort = true

	e.Use(slogecho.New(log))
	e.Use(middleware.Recover())
	e.Use(middleware.RequestID())

	e.StaticFS("/", publicFS)

	e.GET("/", func(c echo.Context) error {
		return c.Render(http.StatusOK, "", pages.HomePage(seedServices()))
	})
	e.GET("/s/:name", func(c echo.Context) error {
		name := c.Param("name")
		if name == "" {
			name = "payments-api"
		}
		return c.Render(http.StatusOK, "", pages.ServicePage(components.ServiceDetail{
			Title:       name,
			Description: "Handles card payments, invoicing, and merchant reconciliation flows.",
			Context:     "Payments",
			Team:        "Payments",
			CustomFields: []components.ServiceField{
				{Label: "Owner", Value: "Payments Platform"},
				{Label: "Repo", Value: "https://github.com/fr0stylo/ddash"},
				{Label: "Runbook", Value: "https://docs.example.com/runbooks/payments-api"},
				{Label: "Dashboard", Value: "https://grafana.example.com/d/payments-api"},
				{Label: "Tier", Value: "Tier 1"},
			},
			Environments: []components.ServiceEnvironment{
				{
					Name:        "production",
					LastDeploy:  "2026-01-04 09:12",
					DeployedRef: "a1b2c3d",
					CommitURL:   "https://github.com/fr0stylo/ddash/commit/a1b2c3d",
				},
				{
					Name:        "staging",
					LastDeploy:  "2026-01-04 08:40",
					DeployedRef: "e7f8a90",
					CommitURL:   "https://github.com/fr0stylo/ddash/commit/e7f8a90",
				},
				{
					Name:        "dev",
					LastDeploy:  "2026-01-04 07:55",
					DeployedRef: "main@3f1d0c2",
					CommitURL:   "https://github.com/fr0stylo/ddash/commit/3f1d0c2",
				},
			},
			PendingCommits: []components.GitCommit{
				{SHA: "7b1d2c4", Message: "Add retry budget to charge flow", URL: "https://github.com/fr0stylo/ddash/commit/7b1d2c4"},
				{SHA: "9c4a0ef", Message: "Clamp webhooks processing concurrency", URL: "https://github.com/fr0stylo/ddash/commit/9c4a0ef"},
				{SHA: "e3f2a11", Message: "Update payment gateway config defaults", URL: "https://github.com/fr0stylo/ddash/commit/e3f2a11"},
			},
			DeploymentHistory: []components.DeploymentRecord{
				{Ref: "a1b2c3d", Commits: 5, DeployedAt: "2026-01-04 09:12", ReleaseURL: "https://github.com/fr0stylo/ddash/releases/tag/a1b2c3d", Environment: "production"},
				{Ref: "e7f8a90", Commits: 2, DeployedAt: "2026-01-04 08:40", ReleaseURL: "https://github.com/fr0stylo/ddash/releases/tag/e7f8a90", Environment: "staging"},
				{Ref: "91aa02c", Commits: 3, DeployedAt: "2026-01-03 18:05", ReleaseURL: "https://github.com/fr0stylo/ddash/releases/tag/91aa02c", Environment: "production"},
				{Ref: "0c12de3", Commits: 7, DeployedAt: "2026-01-02 13:47", ReleaseURL: "https://github.com/fr0stylo/ddash/releases/tag/0c12de3", Environment: "production"},
			},
		}))
	})
	e.GET("/settings", func(c echo.Context) error {
		return c.Render(http.StatusOK, "", pages.SettingsPage())
	})
	e.GET("/deployments", func(c echo.Context) error {
		return c.Render(http.StatusOK, "", pages.DeploymentsPage(seedDeployments()))
	})
	e.GET("/deployments/filter", func(c echo.Context) error {
		env := c.QueryParam("env")
		service := c.QueryParam("service")
		return c.Render(http.StatusOK, "", pages.DeploymentResults(filterDeployments(seedDeployments(), env, service), env, service))
	})
	e.GET("/services/stream", func(c echo.Context) error {
		w := c.Response().Writer
		c.Response().Header().Set("Content-Type", "text/event-stream")
		c.Response().Header().Set("Cache-Control", "no-cache")
		c.Response().Header().Set("Connection", "keep-alive")

		flusher, ok := w.(http.Flusher)
		if !ok {
			return fmt.Errorf("streaming unsupported")
		}

		ctx := c.Request().Context()
		view := c.QueryParam("view")
		ticker := time.NewTicker(3 * time.Second)
		defer ticker.Stop()

		services := seedServices()
		indexes := make([]int, len(services))
		for i := range services {
			indexes[i] = i
		}
		if len(indexes) == 0 {
			return nil
		}

		step := 0
		for {
			select {
			case <-ctx.Done():
				return nil
			case <-ticker.C:
				idx := indexes[step%len(indexes)]
				service := services[idx]
				service.Status = nextServiceStatus(service.Status)
				if service.Status == components.StatusSynced {
					service.LastDeploy = time.Now().Format("2006-01-02 15:04")
				}
				services[idx] = service

				switch view {
				case "table":
					rowPayload, err := renderServiceRow(ctx, services, service)
					if err != nil {
						return err
					}
					fmt.Fprintf(w, "event: %s\ndata: %s\n\n", components.ServiceRowEventName(service), rowPayload)
				case "grid":
					payload, err := renderServiceCard(ctx, services, service)
					if err != nil {
						return err
					}
					fmt.Fprintf(w, "event: %s\ndata: %s\n\n", components.ServiceCardEventName(service), payload)
				default:
					payload, err := renderServiceCard(ctx, services, service)
					if err != nil {
						return err
					}
					fmt.Fprintf(w, "event: %s\ndata: %s\n\n", components.ServiceCardEventName(service), payload)
					rowPayload, err := renderServiceRow(ctx, services, service)
					if err != nil {
						return err
					}
					fmt.Fprintf(w, "event: %s\ndata: %s\n\n", components.ServiceRowEventName(service), rowPayload)
				}
				flusher.Flush()
				step++
			}
		}
	})
	e.GET("/services/grid", func(c echo.Context) error {
		env := c.QueryParam("env")
		return c.Render(http.StatusOK, "", pages.ServiceGridFragment(filterServicesByEnv(seedServices(), env)))
	})
	e.GET("/services/table", func(c echo.Context) error {
		env := c.QueryParam("env")
		return c.Render(http.StatusOK, "", pages.ServiceTableFragment(filterServicesByEnv(seedServices(), env)))
	})
	e.GET("/services/filter", func(c echo.Context) error {
		env := c.QueryParam("env")
		view := c.QueryParam("view")
		services := filterServicesByEnv(seedServices(), env)
		if view == "table" {
			return c.Render(http.StatusOK, "", pages.ServiceTableFragment(services))
		}
		return c.Render(http.StatusOK, "", pages.ServiceGridFragment(services))
	})
	e.GET("/deployments/stream", func(c echo.Context) error {
		w := c.Response().Writer
		c.Response().Header().Set("Content-Type", "text/event-stream")
		c.Response().Header().Set("Cache-Control", "no-cache")
		c.Response().Header().Set("Connection", "keep-alive")

		flusher, ok := w.(http.Flusher)
		if !ok {
			return fmt.Errorf("streaming unsupported")
		}

		ctx := c.Request().Context()
		ticker := time.NewTicker(2 * time.Second)
		defer ticker.Stop()

		type pendingUpdate struct {
			at     time.Time
			row    components.DeploymentRow
			status components.DeploymentStatus
		}

		envFilter := c.QueryParam("env")
		serviceFilter := c.QueryParam("service")

		pending := []pendingUpdate{}
		counter := 0
		for {
			select {
			case <-ctx.Done():
				return nil
			case <-ticker.C:
				now := time.Now()
				if len(pending) > 0 {
					next := []pendingUpdate{}
					for _, item := range pending {
						if now.Before(item.at) {
							next = append(next, item)
							continue
						}
						item.row.Status = item.status
						update, err := renderDeploymentRow(ctx, item.row)
						if err != nil {
							return err
						}
						fmt.Fprintf(w, "event: %s\ndata: %s\n\n", components.DeploymentRowEventName(item.row), update)
					}
					pending = next
					flusher.Flush()
				}

				counter++
				row := components.DeploymentRow{
					Service:     fmt.Sprintf("jobs-worker-%d", counter),
					Environment: "staging",
					DeployedAt:  now.Format("2006-01-02 15:04:05"),
					Status:      components.DeploymentProcessing,
					JobURL:      fmt.Sprintf("https://ci.example.com/jobs/%d", 1900+counter),
				}
				if deploymentMatchesFilter(row, envFilter, serviceFilter) {
					payload, err := renderDeploymentRow(ctx, row)
					if err != nil {
						return err
					}
					fmt.Fprintf(w, "event: deployment-new\ndata: %s\n\n", payload)
					flusher.Flush()

					nextStatus := components.DeploymentSuccess
					if counter%3 == 0 {
						nextStatus = components.DeploymentError
					}
					pending = append(pending, pendingUpdate{
						at:     now.Add(4 * time.Second),
						row:    row,
						status: nextStatus,
					})
				}
			}
		}
	})

	slog.Info("Starting server", "port", 8080)
	e.Logger.Fatal(e.Start(":8080"))
}

type Template struct {
}

func (t *Template) Render(w io.Writer, name string, data interface{}, c echo.Context) error {
	tc, ok := data.(templ.Component)
	if !ok {
		return fmt.Errorf("invalid type %T", data)
	}

	return tc.Render(c.Request().Context(), w)
}

func renderDeploymentRow(ctx context.Context, row components.DeploymentRow) (string, error) {
	var buf bytes.Buffer
	if err := components.DeploymentRowItem(row).Render(ctx, &buf); err != nil {
		return "", err
	}
	return strings.ReplaceAll(buf.String(), "\n", ""), nil
}

func renderServiceCard(ctx context.Context, services []components.Service, service components.Service) (string, error) {
	var buf bytes.Buffer
	prodIndex, hasProd := components.ProductionCommitIndexForTitle(services, service.Title)
	if err := components.ServiceCard(service, prodIndex, hasProd).Render(ctx, &buf); err != nil {
		return "", err
	}
	return strings.ReplaceAll(buf.String(), "\n", ""), nil
}

func renderServiceRow(ctx context.Context, services []components.Service, service components.Service) (string, error) {
	var buf bytes.Buffer
	prodIndex, hasProd := components.ProductionCommitIndexForTitle(services, service.Title)
	if err := components.ServiceTableRow(service, prodIndex, hasProd).Render(ctx, &buf); err != nil {
		return "", err
	}
	return strings.ReplaceAll(buf.String(), "\n", ""), nil
}

func nextServiceStatus(status components.Status) components.Status {
	switch status {
	case components.StatusSynced:
		return components.StatusOutOfSync
	case components.StatusOutOfSync:
		return components.StatusProgressing
	case components.StatusProgressing:
		return components.StatusSynced
	default:
		return components.StatusSynced
	}
}


func deploymentMatchesFilter(row components.DeploymentRow, env string, service string) bool {
	if env != "" && env != "all" && row.Environment != env {
		return false
	}
	if service != "" && service != "all" && row.Service != service {
		return false
	}
	return true
}

func filterDeployments(rows []components.DeploymentRow, env string, service string) []components.DeploymentRow {
	if (env == "" || env == "all") && (service == "" || service == "all") {
		return rows
	}
	filtered := make([]components.DeploymentRow, 0, len(rows))
	for _, row := range rows {
		if deploymentMatchesFilter(row, env, service) {
			filtered = append(filtered, row)
		}
	}
	return filtered
}

func filterServicesByEnv(services []components.Service, env string) []components.Service {
	if env == "" || env == "all" {
		return services
	}
	filtered := make([]components.Service, 0, len(services))
	for _, service := range services {
		if service.Environment == env {
			filtered = append(filtered, service)
		}
	}
	return filtered
}
